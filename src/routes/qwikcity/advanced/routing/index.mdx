# Расширенная маршрутизация

## Не 200-ый ответ

Иногда необходимо отвечать кодами состояния HTTP, отличными от 200. В таких случаях обработчик ответа является тем местом, которое определяет, какой код состояния должен быть возвращен.

Предположим, у нас такая схема расположения файлов:

```
src/
└── routes/
    └── product/
        └── [skuId]/
            └── index.tsx     # https://example.com/product/1234
```

## 404 - Не найдено

Допустим, пользователь делает запрос на недействительный `skuId`, например `https://example.com/product/999`. В этом случае мы хотим вернуть код состояния HTTP 404 и отобразить страницу 404. Место, где мы определяем, является ли запрос корректным, находится в обработчике запроса, который просматривает базу данных. Даже если ответ не имеет 200-ый код, компонент всё-равно получает шанс отрендерить страницу (кроме случая с перенаправлением).

```tsx
// Файл: src/routes/product/[skuId]/index.tsx
import { component$ } from '@builder.io/qwik';

type EndpointData = ProductData | null;

interface ProductData {
  skuId: string;
  price: number;
  description: string;
}
export const onGet: RequestHandler<EndpointData> = async ({ params, response }) => {
  const product = await loadProductFromDatabase(params.skuId);

  if (!product) {
    // Данный товар не найден,
    // но данные все равно передаются рендереру, чтобы он решил, что делать.
    response.status = 404;
    return null;
  } else {
    // ...
  }
};

export default component$(() => {
  const resource = useEndpoint<typeof onGet>(); // эквивалентно useEndpoint<EndpointData>

  if (resource.state == 'resolved' && !resource.resolved) {
    // Ранний возврат для статус-кода 404
    return <div>404: Товар не найден!!!</div>;
  }

  // Нормальный рендеринг
  return (
    <Resource
      value={resource}
      onPending={() => <div>Загрузка...</div>}
      onRejected={() => <div>Ошибка</div>}
      onResolved={() => (
        <>
          <h1>Товар: {product.productId}</h1>
          <p>Цена: {product.price}</p>
          <p>{product.description}</p>
        </>
      )}
    />
  );
});
```

## Сгруппированные макеты

Маршруты общего назначения часто помещают в каталоги, чтобы они могли совместно использовать макеты, и чтобы связанные исходные файлы были логически сгруппированы друг с другом. Однако может возникнуть желание, чтобы каталог, который использовался для группировки похожих файлов и совместного использования макетов, был исключен из общедоступных URL-адресов. Здесь поможет "группировка" макетов (так называемый макет маршрута "без пути").

Если заключить имя каталога в круглые скобки - `(имя)`, то этот каталог не будет включён в URL-адрес.

Например, предположим, что все маршруты, содержащие _account_, расположены в одном каталоге `/account/`. Однако, он может быть удалён из URL-адреса для получения более чистых и кратких URL-адресов. В приведённом ниже примере обратите внимание на то, что пути находятся в каталоге `src/routes/(account)/`, однако URL-адреса исключают `(account)/`.

```
src/
└── routes/
    └── (account)/         # Обратите внимание на круглые скобки
        ├── layout.tsx     # Макет для account
        └── profile/
            └── index.tsx  # https://example.com/profile
        └── settings/
            └── index.tsx  # https://example.com/settings
```

## Именованный макет

Иногда маршруты нуждаются в макетах, коренным образом отличающихся от макетов соседних маршрутов. В этом случае можно определить несколько макетов для одноуровневых маршрутов. Один макет по умолчанию и любое количество именованных макетов. Затем дочерний маршрут может запросить определённый именованный макет.

Qwik City определяет соглашение о том, что макеты находятся внутри каталога `src/routes`, а имена файлов начинаются с `layout`. Именно поэтому макет по умолчанию называется `layout.tsx`. Именованный макет также начинается с `layout`, за которым следует тире `-` и уникальное имя, например `layout-narrow.tsx`.

```
src/
└── routes/
    ├── contact/
    │   └── index@narrow.tsx      # https://example.com/contact (Макет: layout-narrow.tsx)
    ├── layout.tsx                # Макет по умолчанию
    ├── layout-narrow.tsx         # Именованный макет
    └── index.tsx                 # https://example.com/ (Макет: layout.tsx)
```

- `https://example.com/`
  ```
  ┌──────────────────────────────────────────────────┐
  │       src/routes/layout.tsx                      │
  │  ┌────────────────────────────────────────────┐  │
  │  │    src/routes/index.tsx                    │  │
  │  │                                            │  │
  │  └────────────────────────────────────────────┘  │
  │                                                  │
  └──────────────────────────────────────────────────┘
  ```
- `https://example.com/contact`
  ```
  ┌──────────────────────────────────────────────────┐
  │       src/routes/layout-narrow.tsx               │
  │  ┌────────────────────────────────────────────┐  │
  │  │    src/routes/contact/index@narrow.tsx     │  │
  │  │                                            │  │
  │  └────────────────────────────────────────────┘  │
  │                                                  │
  └──────────────────────────────────────────────────┘
  ```

## Вложенный макет

Иногда хочется вложить макеты друг в друга. Содержимое страницы может быть вложено в несколько оборачивающих её макетов, это определяется структурой каталогов.

```
src/
└── routes/
    ├── layout.tsx           # Родительский макет
    └── about/
        ├── layout.tsx       # Дочерний макет
        └── index.tsx        # https://example.com/about
```

В приведённом выше примере есть два макета, которые оборачивают страницу `/about`.

1. `src/routes/layout.tsx`
2. `src/routes/about/layout.tsx`

В этом случае макеты будут вкладываться друг в друга, оборачивая страницу.

```
┌────────────────────────────────────────────────┐
│       src/routes/layout.tsx                    │
│  ┌──────────────────────────────────────────┐  │
│  │    src/routes/about/layout.tsx           │  │
│  │  ┌────────────────────────────────────┐  │  │
│  │  │ src/routes/about/index.tsx         │  │  │
│  │  │                                    │  │  │
│  │  └────────────────────────────────────┘  │  │
│  │                                          │  │
│  └──────────────────────────────────────────┘  │
│                                                │
└────────────────────────────────────────────────┘
```

```tsx
// Файл: src/routes/layout.tsx
export default component$(() => {
  return (
    <main>
      <Slot /> {/* <== Здесь будет вставлен дочерний макет/маршрут */}
    </main>
  );
});
```

```tsx
// Файл: src/routes/about/layout.tsx
export default component$(() => {
  return (
    <section>
      <Slot /> {/* <== Здесь будет вставлен дочерний макет/маршрут */}
    </section>
  );
});
```

```tsx
// Файл: src/routes/about/index.tsx
export default component$(() => {
  return <h1>О сайте</h1>;
});
```

Для приведённого выше примера будет отображаться следующий HTML:

```html
<main>
  <section>
    <h1>О сайте</h1>
  </section>
</main>
```
