---
title: Qwik City Предварительная загрузка
contributors:
  - ulic75
  - mhevery
  - adamdbradley
---

# Предварительная загрузка

Цель предварительной загрузки Qwik заключается не в том, чтобы выполнить загрузку всего приложения, а в том, чтобы предварительно загрузить и кэшировать то, что нужно в данный момент. Когда оптимизатор Qwik разбивает приложение на фрагменты, он способен понять возможные пути взаимодействия с пользователем. И исходя из этого, что не менее важно, он способен понять, какие взаимодействия невозможны.

Например, всё приложение может быть способно только нажать на кнопку, но это также означает, что всё приложение никогда не потребует ререндера. Поскольку Qwik способен понять, что возможно, а что _не_ возможно, он способен наилучшим образом собрать фрагменты для предварительной загрузки.

- [Предварительная загрузка и кэширование сервис-воркером](#ssg-vs-server-side-rendered-ssr)
- [Кэширование пар запросов и ответов](#caching-request-and-response-pairs)
- [Распараллеливание сетевых запросов](#parallelizing-network-requests)

## Предварительная загрузка страницы

При загрузке страницы происходит предварительная загрузка фрагментов, которые могут быть выполнены пользователем. Предположим, что на странице есть слушатель клика по кнопке. Когда страница загружается, самое первое, что делает сервис-воркер, это убеждается, что бандл для этого слушателя предварительно загружен и лежит в [кэше](/qwikcity/advanced/prefetching/index.mdx#caching-request-and-response-pairs). Когда пользователь кликает по кнопке, и Qwik делает запрос к бандлу слушателя событий, он уже находится в кэше, готовый к выполнению.

## Предварительная загрузка при взаимодействии

Можно считать, что загрузка страницы - это первое взаимодействие с пользователем, которое предзагружает то, с чем у пользователя может быть следующее взаимодействие. Когда произойдет следующее взаимодействие, например, открытие модального окна, то Qwik создаст ещё одно событие предварительной загрузки с дополнительными бандлами, которые могут быть использованы при следующем взаимодействии. Предварительная загрузка происходит не только при загрузке страницы, но и по мере того как пользователь взаимодействует с приложением.

## Событие предварительной загрузки

Рекомендуемая стратегия предварительной загрузки заключается в использовании [сервис-воркера](/qwikcity/advanced/prefetching/index.mdx#ssg-vs-server-side-rendered-ssr) для наполнения [кэша](https://developer.mozilla.org/en-US/docs/Web/API/Cache) браузера. Сам Qwik должен быть настроен на использование реализации [prefetchEvent](../../../docs/advanced/prefetching/index.mdx), которая будет отправлять событие предварительной загрузки.

Событие `qprefetch` может содержать различные подробности о том, что нужно загрузить, например:

| Данные | Описание |
| --- | --- |
| `bundles` | Массив имён JavaScript-бандлов для предварительной загрузки. Каждый бандл - коллекция `symbols`. |
| `symbols` | Массив символов (ключей) для предварительной загрузки. Сервис-воркер уже понимает, в какие бандлы входит каждый символ. |
| `links` | _Экспериментальный_. Массив ссылок `hrefs` для предварительной загрузки. |

### Отправка события предварительной загрузки

Ниже приведен пример диспетчеризации события предварительной загрузки. Эти события отправляются из самого Qwik и не требуют от разработчиков отправки этих событий вручную. Кроме того, [сервис-воркер](/qwikcity/advanced/prefetching/index/mdx#prefetching-and-caching-with-a-service-worker) автоматически добавит слушателей для этих событий.

```ts
dispatchEvent(new CustomEvent("qprefetch", { detail: {
  bundles: [...]
}}));
```

# Предварительная загрузка и кэширование с помощью сервис-воркера

Традиционно, сервис-воркер используется для предварительной загрузки большинства или вообще всех бандлов, используемых приложением. [Сервис-воркер](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers) обычно рассматриваются только как способ заставить приложение работать в автономном режиме.

Qwik City, однако, использует сервис-воркер совершенно иначе, чтобы обеспечить мощную стратегию предварительной загрузки и кэширования. Целью Qwik является не загрузка всего приложения, а использование сервис-воркера для динамической предварительной загрузки того, что _возможно_ выполнить. _Не_ за счёт предварительной загрузки всего приложения. Это освобождает ресурсы для запроса только тех небольших частей приложения, с которыми пользователь _может_ взаимодействовать на экране в данный момент.

## Фоновая задача

Преимущество использования сервис-воркера заключается в том, что он является потомком [воркера](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API), который выполняется в фоновом потоке.

> Web-воркер позволяет выполнять операции скрипта в фоновом потоке, отдельном от основного потока выполнения веб-приложения. Преимуществом этого является то, что трудоёмкая обработка может быть выполнена в отдельном потоке, позволяя основному (обычно UI) потоку работать без блокировки/замедления.

Перенеся логику предварительной загрузки и кэширования в сервис-воркер (который является рабочим), мы можем запустить код в фоновом режиме, чтобы не мешать основному потоку пользовательского интерфейса. Не вмешиваясь в основной поток пользовательского интерфейса, мы можем улучшить производительность приложения Qwik для пользователей.

## Интерактивная предварительная загрузка и кэширование

Qwik должен быть настроен на использование реализации [prefetchEvent](../../../docs/advanced/prefetching/index.mdx) (которая также используется в Qwik по умолчанию). Когда Qwik инициирует событие [qprefetch](#prefetch-event), данные события prefetch активно пересылаются установленному и активному сервис-воркеру.

Затем сервис-воркер выполняет предварительную загрузку и кэширует запрошенные бандлы по-требованию. Главный поток просто должен предоставлять сведения о том, какие бандлы ему могут понадобиться, в то время как рабочий сервис сосредоточен только на том, чтобы обеспечить кэширование бандлов. Для этого сервис-воркер заранее заполняет [кэш](https://developer.mozilla.org/en-US/docs/Web/API/Cache) браузера.

1. Браузер уже кэшировал этот фрагмент? Отлично, ничего не делай!
2. Если браузер еще не кэшировал этот фрагмент, давайте запустим запрос на загрузку.

Подробнее про [Кэширование пар запросов и ответов](/qwikcity/advanced/prefetching/index.mdx#caching-request-and-response-pairs).

Кроме того, сервис-воркер следит за тем, чтобы несколько запросов на один и тот же бандл не выполнялись одновременно. Подробнее об этом в документации [Распараллеливание сетевых запросов](#parallelizing-network-requests).

## Пользовательский код сервис-воркера

Установленный сервис-воркер по-прежнему полностью контролируется разработчиком. Например, исходный файл `src/routes/service-worker.ts` становится `/service-worker.js`, который и является скриптом, запрашиваемым браузером. Обратите внимание, что его местоположение в `src/routes` все ещё следует той же схеме маршрутизации, основанной на каталогах.

Ниже приведён пример исходного файла по умолчанию `src/routes/service-worker.ts`:

```ts
import { setupServiceWorker } from '@builder.io/qwik-city/service-worker';

setupServiceWorker();

addEventListener('install', () => self.skipWaiting());

addEventListener('activate', () => self.clients.claim());
```

Исходный код `src/routes/service-worker.ts` может быть изменён разработчиком по своему усмотрению.

Обратите внимание, что функция `setupServiceWorker()` импортируется из `@builder.io/qwik-city/service-worker` и выполняется в верхней части исходного файла. Разработчик может решить сам, когда и где вызывать эту функцию. Например, разработчик может захотеть сначала обработать какие-либо запросы на загрузку данных, и в этом случае он добавит свою собственную функцию выше, чем `setupServiceWorker()`. Или, если он не хочет использовать сервис-воркер Qwik City, он может просто удалить `setupServiceWorker()` из файла.

Кроме того, файл `src/routes/service-worker.ts` по умолчанию поставляется со слушателями событий [установка](https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope/install_event) и [активация](https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope/activate_event), каждый из которых добавлен в нижней части файла. Предоставленные функции обратного вызова являются рекомендуемыми функциями. Однако разработчик может изменять их в зависимости от требований своего приложения.

Другим важным замечанием является то, что перехват запросов Qwik City работает _только_ для бандлов Qwik, он не пытается обрабатывать какие-либо запросы, которые не являются частью его сборки.

Таким образом, хотя Qwik City действительно предоставляет способ предварительной загрузки и кэширования пакетов, он не забирает полностью контроль над сервис-воркером приложения. Это позволяет разработчикам добавлять свою логику в сервис-воркер, не вступая в конфликт с Qwik.

# Кэширование пар запросов и ответов

Во многих традиционных фреймворках предпочтительной стратегией является использование `<link>` с атрибутом `rel` для `предварительной выборки`, `предварительной загрузки` или `предзагрузки модуля`. Однако есть [достаточно известные проблемы](#known-issues-with-link), из-за которых Qwik предпочел не делать `link` стратегией предварительной загрузки по умолчанию (хотя её всё ещё можно [настроить](../../../docs/advanced/prefetching/index.mdx)).

Вместо этого Qwik предпочитает использовать более новый подход, который использует все преимущества [Cache API](https://developer.mozilla.org/en-US/docs/Web/API/Cache) браузера, который также лучше поддерживается по сравнению с [предзагрузкой модуля](#known-issues-with-link).

## Cache API

[Cache API](https://developer.mozilla.org/en-US/docs/Web/API/Cache) часто ассоциируется с сервис-воркерами как способ хранения пар запросов и ответов для того, чтобы приложение могло работать в автономном режиме. Помимо возможности работы приложений без подключения, тот же Cache API предоставляет чрезвычайно мощный механизм предварительной загрузки и кэширования, доступный в Qwik.

Используя установленный и активированный [сервис-воркер](/qwikcity/advanced/prefetching/index.mdx#ssg-vs-server-side-rendered-ssr) для перехвата запросов, Qwik может обрабатывать запросы для _известных ему_ бандлов. В отличие от обычного способа использования сервис-воркера, не предпринимается попытка обрабатывать все запросы, а только запросы на известные бандлы, сгенерированные самим Qwik.

Преимуществом оптимизатора Qwik является то, что он также генерирует файл `q-manifest.json`. Манифест предоставляет подробный граф модулей не только того, как связаны бандлы, но и того, какие ключи-символы находятся внутри каждого бандла. Эти же данные графа модулей предоставляются сервис-воркеру, что позволяет кэшировать каждый сетевой запрос для известных бандлов.

## Динамические импорты и кэширование

Когда Qwik запрашивает модуль, он использует динамический `import()`. Например, предположим, что произошло взаимодействие с пользователем, требующее, чтобы Qwik выполнил динамический импорт для `/build/q-abc.js `. Код для этого будет выглядеть примерно так:

```ts
const module = await import('/build/q-abc.js');
```

Здесь важно то, что сам Qwik ничего не знает о стратегии предварительной загрузки или кэширования. Это просто запрос URL-адреса. Однако, поскольку мы установили сервис-воркер, и сервис-воркер перехватывает запросы, он может проверить URL и сказать: "смотрите, это запрос на `/build/q-abc.js`! Это один из наших пакетов! Давайте сначала проверим, есть ли он уже в кэше, прежде чем выполнять фактический сетевой запрос."

Вот где проявляется мощь сервис-воркера и кэша! Qwik предварительно заполняет кэш для модулей, которые пользователь вскоре может запросить в другом потоке. И ещё лучше, если он уже кэширован, тогда браузеру не нужно ничего делать.

Другие преимущества включают [Распараллеливание сетевых запросов](#parallelizing-network-requests).

## Известные проблемы элемента ссылки

Проблема с подходом относительных ссылок заключается в отсутствии поддержки на _всех_ устройствах, по крайней мере, на момент написания статьи. Кроме того, во время разработки может ввести в заблуждение факт, что это работает везде, тогда как на самом деле на мобильных устройствах нелегко добиться правильной работы предварительной загрузки.

> Предварительная загрузка — функция, которая должна помочь увеличить скорость отклика сайта, но при неправильном сочетании браузера и CDN/сервера она может замедлить работу!
>
> \- <cite><a href="https://andydavies.me/blog/2020/07/08/rel-equals-prefetch-and-the-importance-of-effective-http-slash-2-prioritisation/">Rel=prefetch and the Importance of Effective HTTP/2 Prioritisation</a></cite>

### Ссылки с типом `modulepreload`

- Даже если это указано в спецификации HTML, это не означает, что ваши конечные пользователи будут корректно загружать ваше приложение. [Сайт Can I Use: modulepreload](https://caniuse.com/link-rel-modulepreload)
- Не поддерживается браузером [Safari](https://bugs.webkit.org/show_bug.cgi?id=180574). Это означает, что для пользователей iPhone и iPad (тех, кому предварительная загрузка модулей может принести наибольшую пользу) модули не будут предзагружаться.
- Не поддерживается браузером [Firefox](https://bugzilla.mozilla.org/show_bug.cgi?id=1425310).

## Дублирование запросов

Возможен запуск дублирующихся запросов на один и тот же ресурс. Например, допустим, мы хотим предварительно получить `module-a.js`, и пока он загружается (а мы не знаем заранее, насколько долго он будет загружаться), пользователь взаимодействует с приложением, которое затем решает снова запросить и выполнить `module-a.js`. На момент написания статьи браузеры часто делают отправку повторного запроса, что усугубляет ситуацию.

Подход с использованием сервис-воркера позволяет [избежать этого](#parallelizing-network-requests), определяя уже выполняющийся запрос, ожидая завершения первого запроса на `module-a.js`, а затем клонируя его для второго запроса. Это означает, что произойдет только один сетевой запрос, даже если множество модулей и запросов будут обращаться к одному и тому же ресурсу.

# Распараллеливание сетевых запросов

В разделе про [кэширование пар запросов и ответов](/qwikcity/advanced/prefetching/index.mdx#caching-request-and-response-pairs) мы объяснили мощное сочетание [кэша](https://developer.mozilla.org/en-US/docs/Web/API/Cache) и [сервис-воркера](https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker). Однако мы можем сделать ещё один шаг вперед, убедившись, что дублирующие запросы не создаются для одного и того же пакета, и предотвратить сетевые водопады.

## Избегание дублирования запросов

Например, допустим, конечный пользователь в настоящее время имеет медленное 3G-соединение. Когда он впервые запрашивает страницу лэндинга, устройство, насколько позволяет медленная сеть, загружает HTML и отображает содержимое (та область, где Qwik действительно хорош). При таком медленном соединении было бы обидно, если бы ему пришлось загружать ещё несколько сотен килобайт только для того, чтобы [приложение заработало и стало интерактивным](https://www.builder.io/blog/hydration-is-pure-overhead).

Однако, поскольку приложение было создано с помощью Qwik, конечному пользователю не нужно загружать всё приложение, чтобы оно стало интерактивным. Вместо этого, конечный пользователь уже загрузил HTML приложение, отрендеренное на сервере, и все интерактивные части, такие как кнопка "Добавить в корзину", могут сразу же начать свою предварительную загрузку. Заметьте, что мы загружаем только фактический код слушателя, а _не_ весь стек функций рендеринга дерева компонентов.

В этом примере, чрезвычайно распространённом в реальном мире, устройство немедленно начинает предварительную выборку возможных взаимодействий, которые видны конечному пользователю. Однако из-за медленного соединения, даже если мы сразу начали выполнять предварительную загрузку в [фоновом потоке](#ssg-vs-server-side-rendered-ssr), сам запрос предварительной загрузки может всё ещё находиться в процессе выполнения.

Для демонстрации предположим, что предварительная загрузка для этого бандла занимает две секунды. Однако, через секунду после просмотра страницы пользователь нажимает на кнопку. В традиционном фреймворке, скорее всего, ничего не произойдёт! Если фреймворк еще не закончил загрузку, приложение не гидратировано, приложение не перерендерено, а слушатель события ещё не добавлен к кнопке. К сожалению, взаимодействие с пользователем будет просто потеряно на фреймворке, использующем гидратацию.

Однако, благодаря предварительной загрузке и кэшированию Qwik, если пользователь нажал на кнопку, а мы уже начали запрос одну секунду назад, и до его полного получения осталась одна секунда, то конечному пользователю придётся ждать всего одну секунду. Вспоним, что (для этой демонстрации) он пользуется медленным 3G-соединением. К счастью, пользователь уже получил полную страницу лэндинга, поэтому он уже смотрит на готовую страницу. Далее, фреймворк предварительно загружает только те части приложения, с которыми пользователь может взаимодействовать, и его медленное соединение предназначено только для этих бандлов. Это контрастирует с работой на медленном соединении других фреймворков, загружающих всё в приложении, только чтобы выполнить метод одного слушателя.

Qwik способен перехватывать запросы на известные ему бандлы, и если предварительная загрузка уже находится в процессе, а затем пользователь запрашивает тот же пакет, то он гарантирует, что второй запрос сможет повторно использовать первый, который, возможно, уже закончил загрузку. Выполнение всего этого с помощью [link](/qwikcity/advanced/prefetching/index.mdx#caching-request-and-response-pairs#known-issues-with-link) невозможно, и это показывает, почему Qwik предпочёл не использовать его по умолчанию, а стал вместо этого использовать [Cache API](/qwikcity/advanced/prefetching/index.mdx#caching-request-and-response-pairs).

## Уменьшение сетевых водопадов

Сетевой водопад - это когда многочисленные запросы идут один за другим, как ступеньки вниз по лестнице, а не выполняются параллельно. Водопад сетевых запросов обычно снижает производительность, поскольку модули загружаются последовательно, а не одновременно.

Ниже приведен пример с тремя модулями: A, B и C. Модуль A импортирует B, а B импортирует C. HTML-документ - это то, с чего начинается водопад: сначала запрашивается модуль A.

```ts
import './b.js';
console.log('Module A');
```

```ts
import './c.js';
console.log('Module B');
```

```ts
console.log('Module C');
```

```html
<script type="module" src="./a.js"></script>
```

В этом примере, когда впервые запрашивается модуль `A`, браузер не знает, что он также должен начать запрашивать модули `B` и `C`. Он даже не знает, что ему нужно начать запрашивать модуль `B`, пока модуль `A` не закончит загрузку. Это распространенная проблема, связанная с тем, что браузер не знает заранее, что ему следует начать запрашивать, пока не закончится загрузка каждого модуля.

Однако, поскольку наш сервис-воркер содержит граф модулей, созданный из манифеста, мы знаем все модули, которые _будут_ запрошены далее. Поэтому, когда происходит какое-либо взаимодействие с пользователем, или предварительная загрузка бандла, то браузер инициирует запрос всех пакетов, которые _будут_ запрошены. Это позволяет нам значительно сократить время, необходимое для запроса всех бандлов.
