---
title: Qwik City Распараллеливание сетевых запросов
contributors:
  - mhevery
  - adamdbradley
---

# Распараллеливание сетевых запросов

В документации [Кэширование пар запросов и ответов](../request-response-cache/index.mdx) мы объяснили мощное сочетание [Кэша](https://developer.mozilla.org/en-US/docs/Web/API/Cache) и [Сервис-воркера](https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker). Однако мы можем сделать ещё один шаг вперед, убедившись, что дублирующие запросы не создаются для одного и того же пакета, и предотвратить сетевые водопады.

## Избегание дублирования запросов

Например, допустим, конечный пользователь в настоящее время имеет медленное 3G-соединение. Когда он впервые запрашивает страницу лэндинга, устройство, насколько позволяет медленная сеть, загружает HTML и отображает содержимое (та область, где Qwik действительно хорош). При таком медленном соединении было бы обидно, если бы ему пришлось загружать ещё несколько сотен килобайт только для того, чтобы [приложение заработало и стало интерактивным](https://www.builder.io/blog/hydration-is-pure-overhead).

Однако, поскольку приложение было создано с помощью Qwik, конечному пользователю не нужно загружать всё приложение, чтобы оно стало интерактивным. Вместо этого, конечный пользователь уже загрузил HTML приложение, отрендеренное на сервере, и все интерактивные части, такие как кнопка "Добавить в корзину", могут сразу же начать свою предварительную загрузку. Заметьте, что мы загружаем только фактический код слушателя, а _не_ весь стек функций рендеринга дерева компонентов.

В этом примере, чрезвычайно распространённом в реальном мире, устройство немедленно начинает предварительную выборку возможных взаимодействий, которые видны конечному пользователю. Однако из-за медленного соединения, даже если мы сразу начали выполнять предварительную загрузку в [фоновом потоке](../service-worker-prefetching/index.mdx), сам запрос предварительной загрузки может всё ещё находиться в процессе выполнения.

Для демонстрации предположим, что предварительная загрузка для этого бандла занимает две секунды. Однако, через секунду после просмотра страницы пользователь нажимает на кнопку. В традиционном фреймворке, скорее всего, ничего не произойдёт! Если фреймворк еще не закончил загрузку, приложение не гидратировано, приложение не перерендерено, а слушатель события ещё не добавлен к кнопке. К сожалению, взаимодействие с пользователем будет просто потеряно на фреймворке, использующем гидратацию.

Однако, благодаря предварительной загрузке и кэшированию Qwik, если пользователь нажал на кнопку, а мы уже начали запрос одну секунду назад, и до его полного получения осталась одна секунда, то конечному пользователю придётся ждать всего одну секунду. Вспоним, что (для этой демонстрации) он пользуется медленным 3G-соединением. К счастью, пользователь уже получил полную страницу лэндинга, поэтому он уже смотрит на готовую страницу. Далее, фреймворк предварительно загружает только те части приложения, с которыми пользователь может взаимодействовать, и его медленное соединение предназначено только для этих бандлов. Это контрастирует с работой на медленном соединении других фреймворков, загружающих всё в приложении, только чтобы выполнить метод одного слушателя.

Qwik способен перехватывать запросы на известные ему бандлы, и если предварительная загрузка уже находится в процессе, а затем пользователь запрашивает тот же пакет, то он гарантирует, что второй запрос сможет повторно использовать первый, который, возможно, уже закончил загрузку. Выполнение всего этого с помощью [link](../request-response-cache/index.mdx#known-issues-with-link) невозможно, и это показывает, почему Qwik предпочёл не использовать его по умолчанию, а стал вместо этого использовать [Cache API](../request-response-cache/index.mdx).

## Уменьшение сетевых водопадов

Сетевой водопад - это когда многочисленные запросы идут один за другим, как ступеньки вниз по лестнице, а не выполняются параллельно. Водопад сетевых запросов обычно снижает производительность, поскольку модули загружаются последовательно, а не одновременно.

Ниже приведен пример с тремя модулями: A, B и C. Модуль A импортирует B, а B импортирует C. HTML-документ - это то, с чего начинается водопад: сначала запрашивается модуль A.

```ts
import './b.js';
console.log('Module A');
```

```ts
import './c.js';
console.log('Module B');
```

```ts
console.log('Module C');
```

```html
<script type="module" src="./a.js"></script>
```

В этом примере, когда впервые запрашивается модуль `A`, браузер не знает, что он также должен начать запрашивать модули `B` и `C`. Он даже не знает, что ему нужно начать запрашивать модуль `B`, пока модуль `A` не закончит загрузку. Это распространенная проблема, связанная с тем, что браузер не знает заранее, что ему следует начать запрашивать, пока не закончится загрузка каждого модуля.

Однако, поскольку наш сервис-воркер содержит граф модулей, созданный из манифеста, мы знаем все модули, которые _будут_ запрошены далее. Поэтому, когда происходит какое-либо взаимодействие с пользователем, или предварительная загрузка бандла, то браузер инициирует запрос всех пакетов, которые _будут_ запрошены. Это позволяет нам значительно сократить время, необходимое для запроса всех бандлов.
