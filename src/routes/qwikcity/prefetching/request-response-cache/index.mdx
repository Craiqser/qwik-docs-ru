---
title: Qwik City Кэширование пар запросов и ответов
contributors:
  - mhevery
  - adamdbradley
---

# Кэширование пар запросов и ответов

Во многих традиционных фреймворках предпочтительной стратегией является использование `<link>` с атрибутом `rel` для `предварительной выборки`, `предварительной загрузки` или `предзагрузки модуля`. Однако есть [достаточно известные проблемы](#known-issues-with-link), из-за которых Qwik предпочел не делать `link` стратегией предварительной загрузки по умолчанию (хотя её всё ещё можно [настроить](../../../docs/advanced/prefetching/index.mdx)).

Вместо этого Qwik предпочитает использовать более новый подход, который использует все преимущества [Cache API](https://developer.mozilla.org/en-US/docs/Web/API/Cache) браузера, который также лучше поддерживается по сравнению с [предзагрузкой модуля](#known-issues-with-link).

## Cache API

[Cache API](https://developer.mozilla.org/en-US/docs/Web/API/Cache) часто ассоциируется с сервис-воркерами как способ хранения пар запросов и ответов для того, чтобы приложение могло работать в автономном режиме. Помимо возможности работы приложений без подключения, тот же Cache API предоставляет чрезвычайно мощный механизм предварительной загрузки и кэширования, доступный в Qwik.

Используя установленный и активированный [сервис-воркер](../service-worker-prefetching/index.mdx) для перехвата запросов, Qwik может обрабатывать запросы для _известных ему_ бандлов. В отличие от обычного способа использования сервис-воркера, не предпринимается попытка обрабатывать все запросы, а только запросы на известные бандлы, сгенерированные самим Qwik.

Преимуществом оптимизатора Qwik является то, что он также генерирует файл `q-manifest.json`. Манифест предоставляет подробный граф модулей не только того, как связаны бандлы, но и того, какие ключи-символы находятся внутри каждого бандла. Эти же данные графа модулей предоставляются сервис-воркеру, что позволяет кэшировать каждый сетевой запрос для известных бандлов.

## Динамические импорты и кэширование

Когда Qwik запрашивает модуль, он использует динамический `import()`. Например, предположим, что произошло взаимодействие с пользователем, требующее, чтобы Qwik выполнил динамический импорт для `/build/q-abc.js `. Код для этого будет выглядеть примерно так:

```ts
const module = await import('/build/q-abc.js');
```

Здесь важно то, что сам Qwik ничего не знает о стратегии предварительной загрузки или кэширования. Это просто запрос URL-адреса. Однако, поскольку мы установили сервис-воркер, и сервис-воркер перехватывает запросы, он может проверить URL и сказать: "смотрите, это запрос на `/build/q-abc.js`! Это один из наших пакетов! Давайте сначала проверим, есть ли он уже в кэше, прежде чем выполнять фактический сетевой запрос."

Вот где проявляется мощь сервис-воркера и кэша! Qwik предварительно заполняет кэш для модулей, которые пользователь вскоре может запросить в другом потоке. И ещё лучше, если он уже кэширован, тогда браузеру не нужно ничего делать.

Другие преимущества включают [Распараллеливание сетевых запросов](../parallelizing-network-requests/index.mdx).

## Известные проблемы элемента ссылки

Проблема с подходом относительных ссылок заключается в отсутствии поддержки на _всех_ устройствах, по крайней мере, на момент написания статьи. Кроме того, во время разработки может ввести в заблуждение факт, что это работает везде, тогда как на самом деле на мобильных устройствах нелегко добиться правильной работы предварительной загрузки.

> Предварительная загрузка — функция, которая должна помочь увеличить скорость отклика сайта, но при неправильном сочетании браузера и CDN/сервера она может замедлить работу!
>
> \- <cite><a href="https://andydavies.me/blog/2020/07/08/rel-equals-prefetch-and-the-importance-of-effective-http-slash-2-prioritisation/">Rel=prefetch and the Importance of Effective HTTP/2 Prioritisation</a></cite>

### Ссылки с типом `modulepreload`

- Даже если это указано в спецификации HTML, это не означает, что ваши конечные пользователи будут корректно загружать ваше приложение. [Сайт Can I Use: modulepreload](https://caniuse.com/link-rel-modulepreload)
- Не поддерживается браузером [Safari](https://bugs.webkit.org/show_bug.cgi?id=180574). Это означает, что для пользователей iPhone и iPad (тех, кому предварительная загрузка модулей может принести наибольшую пользу) модули не будут предзагружаться.
- Не поддерживается браузером [Firefox](https://bugzilla.mozilla.org/show_bug.cgi?id=1425310).

## Дублирование запросов

Возможен запуск дублирующихся запросов на один и тот же ресурс. Например, допустим, мы хотим предварительно получить `module-a.js`, и пока он загружается (а мы не знаем заранее, насколько долго он будет загружаться), пользователь взаимодействует с приложением, которое затем решает снова запросить и выполнить `module-a.js`. На момент написания статьи браузеры часто делают отправку повторного запроса, что усугубляет ситуацию.

Подход с использованием сервис-воркера позволяет [избежать этого](../parallelizing-network-requests/index.mdx), определяя уже выполняющийся запрос, ожидая завершения первого запроса на `module-a.js`, а затем клонируя его для второго запроса. Это означает, что произойдет только один сетевой запрос, даже если множество модулей и запросов будут обращаться к одному и тому же ресурсу.
