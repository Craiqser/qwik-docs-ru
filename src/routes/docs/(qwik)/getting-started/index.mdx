---
title: Начало работы
contributors:
  - manucorporat
  - jesperp
  - adamdbradley
  - steve8708
  - cunzaizhuyi
  - mousaAM
  - zanettin
  - Craiqser
  - MyltsinVV
  - literalpie
  - colynyu
  - the-r3aper7
  - ahmadalfy
  - renomureza
  - mhevery
---

import CodeSandbox from '../../../../components/code-sandbox/index.tsx';

# Начало работы с Qwik

Qwik - это новый вид фреймворка, который является [возобновляемым](../concepts/resumable/index.mdx) (без JS и гидратации), современным и [знакомым для разработчиков на React](/docs/guides/qwik-react/).

Если вы хотите попробовать его прямо сейчас, попробуйте наши песочницы в браузере:

- [Stackblitz Qwik + Vite](https://qwik.new)
- [Песочница с примерами](/examples/reactivity/counter/) (только Qwik (без маршрутизации))

## Подготовка

Если вы хотите начать работу с Qwik на своём компьютере, вам понадобится следующее:

- [Node.js v16.8](https://nodejs.org/en/download/) или выше
- Ваша любимая IDE (рекомендуется [vscode](https://code.visualstudio.com/))
- По желанию вы можете прочитать [думай как Qwik](../think-qwik/index.mdx)

## Создание приложения с помощью CLI

Первый шаг - создание приложения. Qwik поставляется с CLI (CLI - Command Line Interface - интерфейс командной строки), который позволяет вам создать базовый рабочий скелет приложения. Мы будем использовать CLI для создания стартового приложения, чтобы вы могли быстрее познакомиться с ним. Qwik поддерживает NPM, yarn и pnpm.

### Запуск Qwik CLI в терминале

Выберите предпочитаемый менеджер пакетов и выполните одну из следующих команд:

```shell
npm create qwik@latest
pnpm create qwik@latest
yarn create qwik@latest
```

CLI проведёт вас через интерактивное меню, чтобы задать название проекта, выбрать один из стартовых шаблонов, и спросит, хотите ли вы установить зависимости. Чтобы узнать больше о создаваемых файлах, ознакомьтесь со [структурой проекта](/docs/project-structure/).

Запуск сервера разработки

```shell
npm start
pnpm start
yarn start
```

## Qwik Hello World

Чтобы познакомить вас с Qwik, мы создали очень простое приложение "Hello World", учебник, затрагивающий наиболее важные концепции Qwik. Для каждой части, которую мы затронем, мы дадим ссылку на соответствующую документацию, где вы сможете узнать больше о данной концепции.

Мы будем использовать https://icanhazdadjoke.com в качестве нашего API для получения случайной шутки. Мы создадим простое приложение, которое будет отображать случайную шутку и кнопку для получения новой шутки.

## 1 Создание маршрута

Всё начинается с обслуживания страницы по определённому маршруту. Итак, давайте создадим простое приложение, показывающее случайную шутку по маршруту `/joke/`. Qwikcity (мета-фреймворк Qwik) использует маршрутизацию [на основе директорий](/docs/routing/). Чтобы начать:

1. Создайте новый файл `index.tsx` в каталоге `src/routes/joke/` вашего проекта (сначала вам нужно будет создать каталог `joke`).

2. Файл `index.tsx` каждого маршрута должен содержать `export default component$(...)`, чтобы Qwikcity знал, какой контент обслуживать. Вставьте следующее содержимое в `src/routes/joke/index.tsx`:

<CodeSandbox src="/src/routes/demo/getting-started/01-route/index.tsx" style={{ height: '6em' }}>
```tsx {3-5}
import { component$ } from "@builder.io/qwik";

export default component$(() => {
  return <div class="section bright">Шутка!</div>;
});
```
</CodeSandbox>

3. Перейдите по адресу `http://127.0.0.1:5173/joke/`, чтобы проверить, что ваша новая страница работает.

> ПРИМЕЧАНИЕ:
>
> - Ваш компонент по умолчанию `шуточного` маршрута вложен в существующий макет. Подробнее о том, что такое макеты и как с ними работать, смотрите раздел [Layout](/docs/layout/).
> - Подробнее о том, как создавать компоненты, смотрите в разделе [Component API](/docs/(qwik)/components/overview/).

## 2 Загрузка данных

Обычно страница загружает отображаемые пользователю данные. Это выполняется с помощью [загрузчиков маршрута](/docs/route-loader/).

1. Откройте файл `src/routes/joke/index.tsx` и добавьте этот код:

```tsx {3-8} /routeLoader\$/
import { routeLoader$ } from '@builder.io/qwik-city';

export const useDadJoke = routeLoader$(async () => {
  const response = await fetch('https://icanhazdadjoke.com/', {
    headers: { Accept: 'application/json' },
  });
  return response.json();
});
```

2. Затем добавьте хук `useDadJoke()` к `default`-компоненту и используйте результат в JSX:

```tsx {2,5} /dadJokeSignal/
export default component$(() => {
  const dadJokeSignal = useDadJoke();
  return (
    <div class="section bright">
      <div>{dadJokeSignal.value.joke}</div>
    </div>
  );
});
```

3. Перейдите по адресу `http://127.0.0.1:5173/`, чтобы увидеть запущенное приложение.

Что делает приведённый выше код?

- Функция, переданная в `routeLoader$`, немедленно вызывается на сервере перед рендером любого компонента и отвечает за загрузку данных;
- `routeLoader$` возвращает use-хук (`useDadJoke`), который может быть использован в компоненте для получения данных сервера.

> **ПРИМЕЧАНИЕ**:
>
> - Функция `routeLoader$` немедленно вызывается на сервере перед рендером любого компонента, даже если ее use-хук не вызывается ни в одном компоненте;
> - Тип возврата `routeLoader$` вычисляется в компоненте без необходимости получения дополнительной информации о типе.

<CodeSandbox src="/src/routes/demo/getting-started/02-loading-data/index.tsx" style={{ height: '6em' }}>
```tsx /routeLoader$/ /useDadJoke/
import { component$ } from '@builder.io/qwik';
import { routeLoader$ } from '@builder.io/qwik-city';

export const useDadJoke = routeLoader$(async () => {
  const response = await fetch('https://icanhazdadjoke.com/', {
    headers: { Accept: 'application/json' },
  });
  return (await response.json()) as {
    id: string;
    status: number;
    joke: string;
  };
});

export default component$(() => {
  const dadJokeSignal = useDadJoke();
  return (
    <div class="section bright">
      <div>{dadJokeSignal.value.joke}</div>
    </div>
  );
});
```
</CodeSandbox>

## 3 Отправка данных на сервер

Ранее мы использовали `routeLoader$` для отправки данных с сервера на клиент. Мы используем [`routeAction$`](/docs/action/) для передачи (отправки) данных с клиента обратно на сервер.

ПРИМЕЧАНИЕ: `routeAction$` - это предпочтительный способ отправки данных на сервер, поскольку он использует нативный API формы браузера, который работает даже при отключенном JavaScript.

Для объявления действия:

1. Откройте `src/routes/joke/index.tsx` и добавьте этот код:

```tsx /routeAction\$/
import {routeAction$, Form} from "@builder.io/qwik-city";

export const useJokeVoteAction = routeAction$((props) => {
  // Предоставляем читателю реализовать это самостоятельно в качестве упражнения.
  console.log("VOTE", props);
});
```

2. Обновите `export default`-компонент для использования хука `useJokeVoteAction`. Это делается путём добавления `<Form>`.

```tsx {3,7-11} /favoriteJokeAction/
export default component$(() => {
  const dadJokeSignal = useDadJoke();
  const favoriteJokeAction = useJokeVoteAction();
  return (
    <div class="section bright">
      <div>{dadJokeSignal.value.joke}</div>
      <Form action={favoriteJokeAction}>
        <input type="hidden" name="jokeID" value={dadJokeSignal.value.id} />
        <button name="vote" value="up">👍</button>
        <button name="vote" value="down">👎</button>
      </Form>
    </div>
  );
});
```

3. Перейдите по адресу `http://127.0.0.1:5173/`, чтобы увидеть запущенное приложение.

Что делает приведенный выше код?

- `routeAction$` используется для получения данных.
  - Функция, переданная в `routeAction$`, вызывается на сервере каждый раз при отправке формы.
  - Функция `routeAction$` возвращает use-хук (`useJokeVoteAction`), который может быть использован в компоненте, отправляющем данные формы.
- `Form` - это удобный компонент, который оборачивает нативный элемент `<form>` браузера.

Обратите внимание:

  - Для проверки смотрите [zod validation](/docs/action/#zod-validation).
  - Функция `routeAction$` работает, даже если JavaScript отключен.
  - Если JavaScript включён, компонент `Form` не позволит браузеру отправить форму, а вместо этого отправит данные с помощью JavaScript и будет эмулировать поведение нативной формы браузера без полного обновления.

<CodeSandbox src="/src/routes/demo/getting-started/03-posting-data/index.tsx" style={{ height: '8em' }}>
```tsx {21,25-29} /favoriteJokeAction/
import { component$ } from '@builder.io/qwik';
import { routeLoader$, Form, routeAction$ } from '@builder.io/qwik-city';

export const useDadJoke = routeLoader$(async () => {
  const response = await fetch('https://icanhazdadjoke.com/', {
    headers: { Accept: 'application/json' },
  });
  return (await response.json()) as {
    id: string;
    status: number;
    joke: string;
  };
});

export const useJokeVoteAction = routeAction$((props) => {
  console.log('VOTE', props);
});

export default component$(() => {
  const dadJokeSignal = useDadJoke();
  const favoriteJokeAction = useJokeVoteAction();
  return (
    <div class="section bright">
      <div>{dadJokeSignal.value.joke}</div>
      <Form action={favoriteJokeAction}>
        <input type="hidden" name="jokeID" value={dadJokeSignal.value.id} />
        <button name="vote" value="up">👍</button>
        <button name="vote" value="down">👎</button>
      </Form>
    </div>
  );
});
```
</CodeSandbox>

## 4 Изменение состояния

Отслеживание состояния и обновление пользовательского интерфейса является основной частью работы приложений. Qwik предоставляет хук `useSignal` для отслеживания состояния приложения. Для получения дополнительной информации смотрите [управление состоянием](/docs/components/state/).

Для объявления состояния:

1. Объявите состояние компонента с помощью `useSignal()`.
   ```tsx /useSignal/
   const isFavoriteSignal = useSignal(false);
   ```
2. Добавьте к компоненту кнопку, которая будет изменять состояние.
   ```tsx /isFavoriteSignal/
   <button onClick$={() => isFavoriteSignal.value = !isFavoriteSignal.value}>
     {isFavoriteSignal.value ? "❤️" : "🤍"}
   </button>
   ```

ПРИМЕЧАНИЕ: Нажатие на кнопку приведет к обновлению состояния, и пользовательский интерфейс будет обновлен.

<CodeSandbox maxHeight={500} src="/src/routes/demo/getting-started/04-state/index.tsx" style={{ height: '10em' }}>
```tsx /isFavoriteSignal/
import { component$, useSignal } from '@builder.io/qwik';
import { routeLoader$, Form, routeAction$ } from '@builder.io/qwik-city';

export const useDadJoke = routeLoader$(async () => {
  const response = await fetch('https://icanhazdadjoke.com/', {
    headers: { Accept: 'application/json' },
  });
  return (await response.json()) as {
    id: string;
    status: number;
    joke: string;
  };
});

export const useJokeVoteAction = routeAction$((props) => {
  console.log('VOTE', props);
});

export default component$(() => {
  const isFavoriteSignal = useSignal(false);
  const dadJokeSignal = useDadJoke();
  const favoriteJokeAction = useJokeVoteAction();

  return (
    <div class="section bright">
      <div>{dadJokeSignal.value.joke}</div>
      <Form action={favoriteJokeAction}>
        <input type="hidden" name="jokeID" value={dadJokeSignal.value.id} />
        <button name="vote" value="up">👍</button>
        <button name="vote" value="down">👎</button>
      </Form>
      <button
        onClick$={() => (isFavoriteSignal.value = !isFavoriteSignal.value)}
      >
        {isFavoriteSignal.value ? '❤️' : '🤍'}
      </button>
    </div>
  );
});
```
</CodeSandbox>

## 5 Задачи и вызов серверного кода

В Qwik [задача](/docs/components/tasks/#usetask) - это работа, которая должна произойти при изменении состояния (аналогично хуку "effect" в других фреймворках). В этом примере мы будем использовать задачу для вызова кода на сервере.

1. Создайте новую задачу, которая отслеживает состояние `isFavoriteSignal`:
   ```tsx /useTask\$/
   useTask$(({ track }) => {});
   ```
2. Добавьте вызов `track` для повторного выполнения задачи при изменении состояния `isFavoriteSignal`:
   ```tsx /track/
   useTask$(({ track }) => {
     track(()=> isFavoriteSignal.value);
   });
   ```
3. Добавьте код, который вы хотите выполнить при изменении состояния:
   ```tsx {3}
   useTask$(({ track }) => {
     track(()=> isFavoriteSignal.value);
     console.log('FAVORITE (isomorphic)', isFavoriteSignal.value);
   });
   ```
4. Если вы хотите, чтобы работа происходила только на сервере, оберните её в `server$()`.
   ```tsx /server\$/ {4-6}
   useTask$(({ track }) => {
     track(()=> isFavoriteSignal.value);
     console.log('FAVORITE (isomorphic)', isFavoriteSignal.value);
     server$(() => {
       console.log('FAVORITE (server)', isFavoriteSignal.value);
     })();
   });
   ```

ПРИМЕЧАНИЕ:

- Обратите внимание, что тело `useTask$` выполняется как на сервере, так и на клиенте (изоморфно);
- Во время SSR сервер выведет в лог `FAVORITE (isomorphic) false` и `FAVORITE (server) false`;
- Когда пользователь взаимодействует с избранным, клиент выведет `FAVORITE (isomorphic) true`, и сервер выведет `FAVORITE (server) true`.

<CodeSandbox maxHeight={500} src="/src/routes/demo/getting-started/05-tasks/index.tsx" style={{ height: '10em' }}>
```tsx {28-34}
import { component$, useSignal, useTask$ } from '@builder.io/qwik';
import {
  routeLoader$,
  Form,
  routeAction$,
  server$,
} from '@builder.io/qwik-city';

export const useDadJoke = routeLoader$(async () => {
  const response = await fetch('https://icanhazdadjoke.com/', {
    headers: { Accept: 'application/json' },
  });
  return (await response.json()) as {
    id: string;
    status: number;
    joke: string;
  };
});

export const useJokeVoteAction = routeAction$((props) => {
  console.log('VOTE', props);
});

export default component$(() => {
  const isFavoriteSignal = useSignal(false);
  const dadJokeSignal = useDadJoke();
  const favoriteJokeAction = useJokeVoteAction();
  useTask$(({ track }) => {
    track(() => isFavoriteSignal.value);
    console.log('FAVORITE (isomorphic)', isFavoriteSignal.value);
    server$(() => {
      console.log('FAVORITE (server)', isFavoriteSignal.value);
    })();
  });
  return (
    <div class="section bright">
      <div>{dadJokeSignal.value.joke}</div>
      <Form action={favoriteJokeAction}>
        <input type="hidden" name="jokeID" value={dadJokeSignal.value.id} />
        <button name="vote" value="up">👍</button>
        <button name="vote" value="down">👎</button>
      </Form>
      <button
        onClick$={() => (isFavoriteSignal.value = !isFavoriteSignal.value)}
      >
        {isFavoriteSignal.value ? '❤️' : '🤍'}
      </button>
    </div>
  );
});
```
</CodeSandbox>

## 6 Стилизация

Стилизация - важная часть любого приложения. Qwik предоставляет способ ассоциировать и ограничить стили вашим компонентом.

Для добавления стилей:

1. Создайте новый файл `src/routes/joke/index.css`:

   ```css
   div {
     font-weight: bold;
   }

   form {
     float: right;
   }
   ```

2. Импортируйте стили в `src/routes/joke/index.tsx`:

   ```tsx
   import STYLES from "./index.css?inline";
   ```

3. Сообщите компоненту о необходимости загрузить стили:
   ```tsx
   useStylesScoped$(STYLES);
   ```

ПРИМЕЧАНИЕ:

- Параметр запроса `?inline` указывает Vite на вставку стилей в компонент;
- Вызов `useStylesScoped$` указывает Qwik ассоциировать стили только с этим компонентом;
- Стили загружаются только в том случае, если они ещё не вставлены SSR, и только для первого компонента.

<CodeSandbox maxHeight={500} src="/src/routes/demo/getting-started/06-styling/index.tsx" style={{ height: '10em' }}>
```tsx /useStylesScoped\$/
import {
  component$,
  useSignal,
  useStylesScoped$,
  useTask$,
} from '@builder.io/qwik';
import {
  routeLoader$,
  Form,
  routeAction$,
  server$,
} from '@builder.io/qwik-city';
import STYLES from './index.css?inline';

export const useDadJoke = routeLoader$(async () => {
  const response = await fetch('https://icanhazdadjoke.com/', {
    headers: { Accept: 'application/json' },
  });
  return (await response.json()) as {
    id: string;
    status: number;
    joke: string;
  };
});

const useJokeVoteAction = routeAction$((props) => {
  console.log('VOTE', props);
});

export default component$(() => {
  useStylesScoped$(STYLES);
  const isFavoriteSignal = useSignal(false);
  const dadJokeSignal = useDadJoke();
  const favoriteJokeAction = useJokeVoteAction();
  useTask$(({ track }) => {
    track(() => isFavoriteSignal.value);
    console.log('FAVORITE (isomorphic)', isFavoriteSignal.value);
    server$(() => {
      console.log('FAVORITE (server)', isFavoriteSignal.value);
    })();
  });
  return (
    <div class="section bright">
      <div>{dadJokeSignal.value.joke}</div>
      <Form action={favoriteJokeAction}>
        <input type="hidden" name="jokeID" value={dadJokeSignal.value.id} />
        <button name="vote" value="up">👍</button>
        <button name="vote" value="down">👎</button>
      </Form>
      <button
        onClick$={() => (isFavoriteSignal.value = !isFavoriteSignal.value)}
      >
        {isFavoriteSignal.value ? '❤️' : '🤍'}
      </button>
    </div>
  );
});
```
</CodeSandbox>

## 7 Предварительный просмотр

Мы создали очень простое приложение, которое дало вам обзор ключевых концепций Qwik и API. Приложение работает в режиме dev, который использует горячую модульную перезагрузку (HMR) для непрерывного обновления приложения при изменении кода.

В режиме разработки:

- Каждый файл загружается отдельно, что может вызвать водопад на вкладке сети.
- Спекулятивная загрузка бандлов отсутствует, поэтому при первом взаимодействии может возникнуть задержка.

Давайте создадим сборку для рабочей среды, чтобы посмотреть, как приложение будет доставлено пользователю и как вышеописанное будет исправлено.

Чтобы создать сборку для предварительного просмотра:

1. Запустите `npm run preview` для создания сборки для рабочей среды.

ПРИМЕЧАНИЕ:

- Теперь ваше приложение собрано для рабочей среды и будет работать на другом порту.
- Если вы сейчас будете взаимодействовать с приложением, то на вкладке Network в инструментах разработчика должно быть видно, что бандлы мгновенно доставляются из кэша [сервис-воркера](/docs/advanced/speculative-module-fetching/).

## Обзор

Поздравляем! Вы справились. Этот обзор намеренно краток, чтобы ознакомить вас с различными частями Qwik. Мы рекомендуем вам глубоко погрузиться в вышеупомянутые концепции, чтобы узнать больше. Вот несколько ключевых выводов:

- [Структура проекта](/docs/(qwikcity)/project-structure/index.mdx)
- [Маршрутизация на основе каталогов](/docs/(qwikcity)/routing/index.mdx)
- [Компонент](/docs/(qwik)/components/overview/index.mdx)
- [Загрузчики маршрута](/docs/(qwikcity)/route-loader/index.mdx)
- [Действия формы](/docs/(qwikcity)/action/index.mdx) (и [валидация с помощью zod](/docs/(qwikcity)/action/index.mdx#zod-validation))
- [Управление состоянием](/docs/(qwik)/components/state/index.mdx)
- [Задачи](/docs/(qwik)/components/tasks/index.mdx#use-usetask-when-you-need-to)
- [Кеш сервис-воркера](/docs/(qwik)/advanced/index.mdxspeculative-module-fetching/)
