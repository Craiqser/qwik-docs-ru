---
title: События
contributors:
  - voluntadpear
  - the-r3aper7
  - RATIU5
  - manucorporat
  - nnelgxorz
  - adamdbradley
  - hamatoyogi
  - fleish80
  - cunzaizhuyi
  - Pika-Pool
---

# События

Для того чтобы веб-приложение было интерактивным, оно нуждается в реагировании на пользовательские события. Это делается путем регистрации функций обратного вызова в шаблоне JSX.

В приведённом ниже примере атрибут `onClick$` элемента `<button>` используется, чтобы сообщить Qwik, что функция обратного вызова `() => store.count++` должна выполняться каждый раз, когда на `<button>` происходит событие `click`.

Обратите внимание, что `onClick$` заканчивается на [`$`](todo/correct-link). Это подсказка как [оптимизатору](/docs/(qwik)/advanced/optimizer) так и разработчику о том, что в этом месте происходит специальное преобразование. Наличие суффикса `$` подразумевает здесь границу ленивой загрузки. Код, связанный с обработкой события `click`, не будет загружаться до тех пор, пока пользователь не запустит это событие.

```tsx
import { component$, useSignal } from '@builder.io/qwik';

export const Counter = component$(() => {
  const count = useSignal(0);

  return <button onClick$={() => count.value++}>{count.value}</button>;
});
```

В реальных приложениях слушатель может обращаться к сложному коду. Создавая границу ленивой загрузки (с помощью `$`), Qwik может выделить весь код, расположенный в обработчике, в отдельный фрагмент, и отложить его загрузку до тех пор, пока пользователь не нажмёт на кнопку.

Вы также можете передавать [QRL-выражения](/docs/(qwik)/advanced/qrl/) в качестве значений для слушателей событий. Например, приведённый выше пример можно записать следующим образом:

```tsx
import { component$, useSignal, $ } from '@builder.io/qwik';

export const Counter = component$(() => {
  const count = useSignal(0);
  const incrementCount = $(() => count.value++);

  return <button onClick$={incrementCount}>{count.value}</button>;
});
```

## Prevent default

Из-за асинхронной природы Qwik выполнение обработчика события может быть отложено, поскольку реализация еще не загружена.

Это создает проблему, когда обработчику события необходимо предотвратить поведение события по умолчанию. Традиционный `event.preventDefault()` не будет работать, поэтому вместо этого используйте атрибут Qwik `preventdefault:{eventName}`:

```tsx
import { component$ } from '@builder.io/qwik';

export const PreventDefaultExample = component$(() => {
  return (
    <a
      href="/about"
      preventdefault:click // Это предотвратит поведение по умолчанию события "click".
      onClick$={(event) => {
        // PreventDefault здесь не сработает, так как хэндл отправляется асинхронно.
        // event.preventDefault();
        singlePageNavigate('/about');
      }}
    >
      Перейти на страницу с информацией
    </a>
  );
});
```

### Синхронная обработка событий

В некоторых случаях необходимо обрабатывать событие традиционным способом, поскольку некоторые API должны использоваться синхронно. Например, события перетаскивания в противном случае не будут работать.

В таких случаях мы можем использовать `useVisibleTask`, чтобы программно добавить слушателя событий, используя DOM API напрямую.

```tsx
import { component$, useVisibleTask$ } from '@builder.io/qwik';

export const DragAndDropExample = component$(() => {
  const elementRef = useSignal<HTMLElement>()
  useVisibleTask$(({cleanup}) => {
    if (elementRef.value) {
      // Используйте DOM API для добавления слушателя событий.
      const listener = (event) => {
        event.dataTransfer.setData('text/plain', 'Hello World');
      };

      elementRef.value.addEventListener('dragstart', listener);
      cleanup(() => {
        elementRef.value.removeEventListener('dragstart', listener);
      });
    }
  });

  return (
    <div ref={elementRef}>
      Тяни меня!
    </div>
  );
});
```

> Обратите внимание, что использование `VisibleTask` для прослушивания событий является анти-паттерном в Qwik, который добавит много ненужных накладных расходов, используйте его только тогда, когда у вас нет другого выбора. В 99% случаев для прослушивания событий следует использовать JSX: `<div onClick$={...}>`.

## События и компоненты

Компоненты - это функции, не элементы. Поскольку события DOM не существуют сами по себе, можно определить их как параметры.

Давайте посмотрим, как объявляется дочерний компонент, в котором события используются в качестве параметров.

```tsx
import { PropFunction, component$ } from '@builder.io/qwik';

interface CmpButtonProps {
  onClick$?: PropFunction<() => void>;
}

export const CmpButton = component$((props: CmpButtonProps) => {
  return (
    <button onClick$={props.onClick$}>
      <Slot />
    </button>
  );
});
```

С точки зрения Qwik, передача событий компоненту эквивалентна передаче параметров.

В нашем примере мы объявляем все параметры в интерфейсе `CmpButtonProps`. В частности, обратите внимание на объявление `onClick$: PropFunction<() => void>`.

Затем, когда мы захотим использовать `<CmpButton>`, мы можем сделать следующее:

```tsx
<CmpButton onClick$={() => store.cmpCount++}>{store.cmpCount}</CmpButton>
```

## События объектов window и document

До сих пор мы обсуждали, как прослушивать события, идущие от элементов разметки. Есть события (например, `scroll` и `mousemove`), которые требуют прослушивания на объекте `window` или `document`. По этой причине Qwik позволяет использовать префиксы `document:on` и `window:on`.

```tsx
import { component$, useSignal } from '@builder.io/qwik';

export const EventExample = component$(() => {
  const scroll = useSignal(0);
  const mouse = useSignal({ x: 0, y: 0 });
  const clickCount = useSignal(0);

  return (
    <button
      window:onScroll$={(e) => (scroll.value = window.scrollY)}
      document:onMouseMove$={(e) => {
        const { x, y } = e;
        mouse.value = { x, y };
      }}
      onClick$={() => clickCount.value++}
    >
      scroll: {scroll.value}
      mouseMove: {mouse.value.x}, {mouse.value.y}
      click: {clickCount.value}
    </button>
  );
});
```

Назначение `window:on`/`document:on` - зарегистрировать событие компонента в текущем местоположении DOM, но заставить его получать события от `window`/`document`. В этом есть два преимущества:

1. События могут быть зарегистрированы декларативно в вашем JSX;
2. События автоматически очищаются при уничтожении компонента (не требуют явной очистки).

## Хуки useOn

- [useOn](./index.mdx#useon)
- [useOnWindow](./index.mdx#useonwindow)
- [useOnDocument](./index.mdx#useondocument)

### useOn

Хук `useOn` добавит слушателя DOM-событий на уровне компонента.

```tsx
import { component$, useSignal, useOn, $ } from '@builder.io/qwik';

export const ClickableComponent = component$(() => {
  useOn(
    'click',
    $(() => {
      alert('Alert from Clickable Component.');
    })
  );
  return <div>click from other component 1</div>;
});

export const HoverComponent = component$(() => {
  const isHover = useSignal(false);
  useOn(
    'mouseover',
    $(() => {
      isHover.value = true;
    })
  );
  return <div>{isHover.value ? 'Now Hovering' : 'Not Hovering'}</div>;
});

export default component$(() => {
  return (
    <>
      <ClickableComponent />
      <HoverComponent />
    </>
  );
});
```

### useOnWindow

Хук `useOnWindow` добавит слушателя событий к объекту `window`.

```tsx
import { component$, useOnWindow, $ } from '@builder.io/qwik';

export const Online = component$(() => {
  useOnWindow(
    'online',
    $(() => {
      alert('Your Device is now Online');
    })
  );
  useOnWindow(
    'offline',
    $(() => {
      alert('Your Device is now Offline');
    })
  );
  return <div></div>;
});

export default component$(() => {
  return <Online />;
});
```

### useOnDocument

Хук `useOnDocument` добавит слушателя событий к объекту `document`.

```tsx
import { component$, useSignal, $, useOnDocument } from '@builder.io/qwik';

export const KeyBoard = component$(() => {
  const keyPressed = useSignal('');
  useOnDocument(
    'keydown',
    $((event) => {
      keyPressed.value = keyPressed.value + event.key;
    })
  );
  return <div>{keyPressed.value}</div>;
});

export default component$(() => {
  return <KeyBoard />;
});
```
