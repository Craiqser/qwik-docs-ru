---
title: События
contributors:
  - voluntadpear
  - the-r3aper7
  - RATIU5
  - manucorporat
  - nnelgxorz
  - adamdbradley
  - hamatoyogi
  - fleish80
  - cunzaizhuyi
  - Pika-Pool
---

import CodeSandbox from '../../../../../components/code-sandbox/index.tsx';

# События

Для того чтобы веб-приложение было интерактивным, оно нуждается в реагировании на пользовательские события. Это делается путем регистрации функций обратного вызова в шаблоне JSX. Обработчики событий регистрируются с помощью атрибута `on{EventName}$`. Например, атрибут `onClick$` используется для прослушивания событий `click`.

```tsx /onClick$/
<button onClick$={() => alert('CLICKED!')}>click me!</button>
```

## Встроенный обработчик

В приведённом ниже примере атрибут `onClick$` элемента `<button>` используется, чтобы сообщить Qwik, что функция обратного вызова `() => store.count++` должна выполняться каждый раз, когда на элементе `<button>` происходит событие `click`.

<CodeSandbox src="/src/routes/demo/state/counter-signal/index.tsx" sandboxStyle={{ height: '6em' }}>
```tsx {7} /onClick$/
import { component$, useSignal } from '@builder.io/qwik';

export default component$(() => {
  const count = useSignal(0);

  return (
    <button onClick$={() => count.value++}>
      Прибавить {count.value}
    </button>
  );
});
```
</CodeSandbox>

Обратите внимание, что `onClick$` оканчивается на [`$`](/docs/advanced/dollar/). Это подсказка как [оптимизатору](/docs/advanced/optimizer) так и разработчику о том, что в этом месте происходит специальное преобразование. Наличие суффикса `$` подразумевает здесь границу ленивой загрузки. Код, связанный с обработкой события `click`, не будет загружаться до тех пор, пока пользователь не запустит это событие. Код, связанный с обработчиком события `click`, не будет загружен в JavaScript VM до тех пор, пока пользователь не вызовет событие `click`, однако он будет сразу [загружен в кэш браузера](docs/advanced/speculative-module-fetching/), чтобы не вызывать задержек при первом взаимодействии.

> В реальных приложениях слушатель может обращаться к сложному коду. Создавая границу ленивой загрузки (с помощью `$`), Qwik может тришейкнуть весь код, расположенный в обработчике, и отложить его загрузку до тех пор, пока пользователь не нажмёт на кнопку.

## Повторное использование обработчиков событий

Если мы хотим повторно использовать один и тот же обработчик события для нескольких элементов или событий, мы должны извлечь обработчик события в [`QRLs`](/docs/advanced/qrl/) и передать его слушателю события. Для этого нам нужно импортировать `$` из `@builder.io/qwik` и обернуть в него обработчик событий.

Например, приведённый выше пример можно записать следующим образом:

<CodeSandbox src="/src/routes/demo/events/extracted-handler/index.tsx" sandboxStyle={{ height: '6em' }}>
```tsx {5} /increment/#a
import { component$, useSignal, $ } from '@builder.io/qwik';

export default component$(() => {
  const count = useSignal(0);
  const increment = $(() => count.value++);
  return (
    <>
      <button onClick$={increment}>Прибавить</button>
      <div>Счёт: {count.value}</div>
    </>
  );
});
```
</CodeSandbox>

> **Примечание:** Если вы извлекаете обработчик события, то вы должны вручную обернуть обработчик события в `$(...handler...)`, чтобы его можно было лениво присоединить.

## Объект события

Первым аргументом обработчика события является объект `Event`. Этот объект содержит информацию о событии, которое вызвало обработчик. Например, объект `Event` для события `click` содержит информацию о положении мыши и элементе, на котором был клик мыши. Вы можете ознакомиться с [документами MDN, чтобы узнать больше подробностей о каждом событии DOM](https://developer.mozilla.org/en-US/docs/Web/API/Event).

<CodeSandbox src="/src/routes/demo/events/mouse-position/index.tsx" sandboxStyle={{ height: '6em' }}>
```tsx /event/
import { component$, useSignal } from '@builder.io/qwik';

export default component$(() => {
  const position = useSignal<{ x: number; y: number }>();
  return (
    <div
      onClick$={(event) => (position.value = { x: event.x, y: event.y })}
      style="height: 100vh"
    >
      <div>
        Позиция клика: ({position.value?.x}, {position.value?.y})
      </div>
    </div>
  );
});
```
</CodeSandbox>

## Асинхронные события

Из-за асинхронной природы Qwik выполнение обработчика события может быть отложено, поскольку реализация еще не загружена в виртуальную машину JavaScript. Из-за асинхронной природы обработки событий в Qwik следующие API для объекта `Event` не будут работать:

- `event.preventDefault()`.
- `event.currentTarget`

### `Prevent default`

Поскольку обработка событий является асинхронной, вы не можете использовать `event.preventDefault()`. Для решения этой проблемы Qwik вводит декларативный способ предотвращения с помощью атрибута `preventdefault:{eventName}`.

<CodeSandbox src="/src/routes/demo/events/preventdefault/index.tsx" sandboxStyle={{ height: '6em' }}>
```tsx {7}
import { component$ } from '@builder.io/qwik';

export default component$(() => {
  return (
    <a
      href="/about"
      preventdefault:click // Это предотвратит поведение по умолчанию для события клика.
      onClick$={() => {
        // event.PreventDefault() здесь не сработает, потому что обработчик управляется асинхронно.
        alert('Do something else to simulate navigation...');
      }}
    >
      Перейти на страницу описания
    </a>
  );
});
```
</CodeSandbox>

### `Event target`

Поскольку обработка событий является асинхронной, вы не можете использовать `event.currentTarget`. Для решения этой проблемы обработчики Qwik предоставляют `currentTarget` в качестве второго аргумента.

<CodeSandbox src="/src/routes/demo/events/target/index.tsx" sandboxStyle={{ height: '10em' }}>
```tsx /currentTarget/
import { component$, useSignal } from '@builder.io/qwik';

export default component$(() => {
  const currentElm = useSignal<HTMLElement|null>(null);
  const targetElm = useSignal<HTMLElement|null>(null);

  return (
    <div onClick$={(event, currentTarget) => {
      currentElm.value = currentTarget;
      targetElm.value = event.target as HTMLElement;
    }}>
      Click on any text <code>target</code> and <code>currentElm</code> of the event.
      <hr/>
      <span>Hello <b>World</b>!</span>
      <hr/>
      <ul>
        <li>currentElm: {currentElm.value?.tagName}</li>
        <li>target: {targetElm.value?.tagName}</li>
      </ul>
    </div>
  );
});
```
</CodeSandbox>

> **Примечание:** `currentTarget` в DOM указывает на элемент, к которому был прикреплён слушатель события. В приведённом примере это всегда будет элемент `<DIV>`.

### Синхронная обработка событий

В некоторых случаях необходимо обрабатывать событие традиционным способом, поскольку некоторые API должны использоваться синхронно. Например, событие `dragstart` должно обрабатываться синхронно, поэтому его нельзя совместить с ленивым выполнением кода Qwik.

Для этого мы можем использовать `useVisibleTask`, чтобы программно добавить слушателя событий, используя DOM API напрямую.

<CodeSandbox src="/src/routes/demo/events/synchronous/index.tsx" sandboxStyle={{ height: '10em' }}>
```tsx {7-20}
import { component$, useSignal, useVisibleTask$ } from '@builder.io/qwik';

export default component$(() => {
  const draggableRef = useSignal<HTMLElement>();
  const dragStatus = useSignal('');

  useVisibleTask$(({ cleanup }) => {
    if (draggableRef.value) {
      // Использование DOM API для добавления слушателя событий.
      const dragstart = () => (dragStatus.value = 'dragstart');
      const dragend = () => (dragStatus.value = 'dragend');

      draggableRef.value!.addEventListener('dragstart', dragstart);
      draggableRef.value!.addEventListener('dragend', dragend);
      cleanup(() => {
        draggableRef.value!.removeEventListener('dragstart', dragstart);
        draggableRef.value!.removeEventListener('dragend', dragend);
      });
    }
  });

  return (
    <div>
      <div draggable ref={draggableRef}>
        Потяни меня!
      </div>
      <div>{dragStatus.value}</div>
    </div>
  );
});
```
</CodeSandbox>

> **ПРИМЕЧАНИЕ** Использование `VisibleTask` для прослушивания событий является анти-паттерном в Qwik, поскольку это приводит к немедленному выполнению кода в браузере, что нарушает принцип [возобновляемости](/docs/concepts/resumable/). Используйте его только тогда, когда у вас нет другого выбора. В большинстве случаев для прослушивания событий следует использовать JSX: `<div onClick$={...}>` или `useOn(...)` методы событий, если вам нужно слушать события программно.

## `PropFunction`

При создании компонентов иногда приходится передавать то, что выглядит как обработчики событий (функции обратного вызова, которые не являются событиями DOM). Границы компонентов в Qwik должны быть сериализуемыми, а функции не являются сериализуемыми, если они не преобразованы в QRL с помощью оптимизатора. Это делается с помощью суффикса `$`. QRL являются асинхронными, поэтому нам нужно сообщить TypeScript, что функция не может быть вызвана синхронно, мы делаем это через тип `PropFunction`.

```tsx
<CmpButton onClick={() => alert('CLICKED!')}>Нажми меня!</CmpButton>
```

Вышеописанное невозможно, поскольку `onClick` - это функция, которая не является сериализуемой. Нам нужно указать оптимизатору на преобразование нашей функции в QRL. Это делается путём именования свойства с суффиксом `$`, как в данном примере.

<CodeSandbox src="/src/routes/demo/events/prop-function/index.tsx" sandboxStyle={{ height: '10em' }}>
```tsx
import { type PropFunction, component$, Slot } from '@builder.io/qwik';

export default component$(() => {
  return <CmpButton onClick$={() => alert('CLICKED!')}>Нажми меня!</CmpButton>;
});

export const CmpButton = component$<{
  // Важно сообщить TypeScript, что это async
  onClick$?: PropFunction<() => void>;
}>(({ onClick$ }) => {
  return (
    <button onClick$={onClick$}>
      <Slot />
    </button>
  );
});
```
</CodeSandbox>

## События объектов window и document

До сих пор мы обсуждали, как прослушивать события, идущие от элементов разметки. Есть события (например, `scroll` и `mousemove`), которые требуют прослушивания на объекте `window` или `document`. По этой причине Qwik позволяет использовать префиксы `document:on` и `window:on`.

Назначение `window:on`/`document:on` - зарегистрировать событие компонента в текущем местоположении DOM, но заставить его получать события от `window`/`document`. В этом есть два преимущества:

1. События могут быть зарегистрированы декларативно в вашем JSX;
2. События автоматически очищаются при уничтожении компонента (не требуют явной очистки).

## Хуки `useOn[window|document]`

- `useOn()`: слушает события на корневом элементе текущего компонента;
- `useOnWindow()`: слушает события на объекте `window`;
- `useOnDocument()`: слушает события на объекте `document`.

Хук `useOn[window|document]()` программно добавит слушателя событий на основе DOM на уровне компонента. Это бывает полезно при создании своих собственных хуков или если вы не знаете имя события на момент компиляции.

<CodeSandbox src="/src/routes/demo/events/use-on/index.tsx" sandboxStyle={{ height: '10em' }}>
```tsx
import { $, component$, useOnDocument, useStore } from '@builder.io/qwik';

// Предполагаем многоразовое использование, не имеющее доступа к JSX,
// но нам нужно зарегистрировать обработчики событий.
function useMousePosition() {
  const position = useStore({ x: 0, y: 0 });
  useOnDocument(
    'mousemove',
    $((event) => {
      const { x, y } = event as MouseEvent;
      position.x = x;
      position.y = y;
    })
  );
  return position;
}

export default component$(() => {
  const pos = useMousePosition();
  return (
    <div>
      Позиция мыши: ({pos.x}, {pos.y})
    </div>
  );
});
```
</CodeSandbox>
