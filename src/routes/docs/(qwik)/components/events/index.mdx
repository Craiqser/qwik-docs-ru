---
title: События
contributors:
  - voluntadpear
  - the-r3aper7
  - RATIU5
  - manucorporat
  - nnelgxorz
  - adamdbradley
  - hamatoyogi
  - fleish80
  - cunzaizhuyi
  - Pika-Pool
---
import CodeExample from '../../../../../components/code-example/index.tsx';
import CounterSignal from 'source:/src/routes/demo/state/counter-signal/index.tsx';
import ExtractedHandler from 'source:/src/routes/demo/events/extracted-handler/index.tsx';
import PreventDefault from 'source:/src/routes/demo/events/preventdefault/index.tsx';
import Target from 'source:/src/routes/demo/events/target/index.tsx';
import Synchronous from 'source:/src/routes/demo/events/synchronous/index.tsx';
import MousePosition from 'source:/src/routes/demo/events/mouse-position/index.tsx';
import PropFunction from 'source:/src/routes/demo/events/prop-function/index.tsx';
import GlobalEvents from 'source:/src/routes/demo/events/global-events/index.tsx';
import UseOn from 'source:/src/routes/demo/events/use-on/index.tsx';

# События

## Встроенный обработчик

Для того чтобы веб-приложение было интерактивным, оно нуждается в реагировании на пользовательские события. Это делается путем регистрации функций обратного вызова в шаблоне JSX.

В приведённом ниже примере атрибут `onClick$` элемента `<button>` используется, чтобы сообщить Qwik, что функция обратного вызова `() => store.count++` должна выполняться каждый раз, когда на элементе `<button>` происходит событие `click`.

Обратите внимание, что `onClick$` оканчивается на [`$`](/docs/advanced/dollar/). Это подсказка как [оптимизатору](/docs/(qwik)/advanced/optimizer) так и разработчику о том, что в этом месте происходит специальное преобразование. Наличие суффикса `$` подразумевает здесь границу ленивой загрузки. Код, связанный с обработкой события `click`, не будет загружаться до тех пор, пока пользователь не запустит это событие.

Код, связанный с обработчиком события `click`, не будет загружен в JavaScript VM до тех пор, пока пользователь не вызовет событие `click`, однако он будет сразу [загружен в кэш браузера](docs/advanced/speculative-module-fetching/), чтобы не вызывать задержек при первом взаимодействии.

<CodeExample src={CounterSignal} sandboxStyle={{height: '6em'}}/>

В реальных приложениях слушатель может обращаться к сложному коду. Создавая границу ленивой загрузки (с помощью `$`), Qwik может древовидно встряхнуть весь код, расположенный в обработчике, и отложить его загрузку до тех пор, пока пользователь не нажмёт на кнопку.

## Извлечение обработчика

Другим вариантом является передача [QRL-выражения](/docs/(qwik)/advanced/qrl/) в качестве значения для слушателя событий. Например, приведённый выше пример можно записать следующим образом:

<CodeExample src={ExtractedHandler} sandboxStyle={{height: '6em'}}/>

> **Примечание:** Если вы извлекаете обработчик события, то вы должны вручную обернуть обработчик события в `$()`, чтобы его можно было подключить лениво.

## Объект события

Первым аргументом обработчика события является объект `Event`. Этот объект содержит информацию о событии, которое вызвало обработчик. Например, объект `Event` для события `click` содержит информацию о положении мыши и элементе, на котором был клик мыши.

<CodeExample src={MousePosition} sandboxStyle={{height: '6em'}}/>

### Prevent default

Поскольку обработка событий является асинхронной, вы не можете использовать `event.preventDefault()`. Для решения этой проблемы Qwik вводит декларативный способ предотвращения с помощью атрибута `preventdefault:{eventName}`.

<CodeExample src={PreventDefault} sandboxStyle={{height: '6em'}}/>

### Target

Поскольку обработка событий является асинхронной, вы не можете использовать `event.currentTarget`. Для решения этой проблемы обработчики Qwik предоставляют `currentTarget` в качестве второго аргумента.

<CodeExample src={Target} sandboxStyle={{height: '10em'}}/>

> **Примечание:** `currentTarget` в DOM указывает на элемент, к которому был прикреплён слушатель события. В приведённом примере это всегда будет элемент `<DIV>`.

### Синхронная обработка событий

В некоторых случаях необходимо обрабатывать событие традиционным способом, поскольку некоторые API должны использоваться синхронно. Например, событие `dragstart` должно обрабатываться синхронно, поэтому его нельзя совместить с ленивым выполнением кода Qwik.

Для этого мы можем использовать `useVisibleTask`, чтобы программно добавить слушателя событий, используя DOM API напрямую.

<CodeExample src={Synchronous} sandboxStyle={{height: '10em'}}/>

> **ПРИМЕЧАНИЕ** Использование `VisibleTask` для прослушивания событий является анти-паттерном в Qwik, поскольку это приводит к немедленному выполнению кода в браузере, что нарушает принцип [возобновляемости](/docs/concepts/resumable/). Используйте его только тогда, когда у вас нет другого выбора. В большинстве случаев для прослушивания событий следует использовать JSX: `<div onClick$={...}>` или `useOn(...)` методы событий, если вам нужно слушать события программно.

## `PropFunction`

При создании компонентов иногда приходится передавать то, что выглядит как обработчики событий (функции обратного вызова, которые не являются событиями DOM). Границы компонентов в Qwik должны быть сериализуемыми, а функции не являются сериализуемыми, если они не преобразованы в QRL с помощью оптимизатора. Это делается с помощью суффикса `$`. QRL являются асинхронными, поэтому нам нужно сообщить TypeScript, что функция не может быть вызвана синхронно, мы делаем это через тип `PropFunction`.

```tsx
<CmpButton onClick={() => alert('CLICKED!')}>Нажми меня!</CmpButton>
```

Вышеописанное невозможно, поскольку `onClick` - это функция, которая не является сериализуемой. Нам нужно указать оптимизатору на преобразование нашей функции в QRL. Это делается путём именования свойства с суффиксом `$`, как в данном примере.

<CodeExample src={PropFunction} sandboxStyle={{height: '10em'}}/>

## События объектов window и document

До сих пор мы обсуждали, как прослушивать события, идущие от элементов разметки. Есть события (например, `scroll` и `mousemove`), которые требуют прослушивания на объекте `window` или `document`. По этой причине Qwik позволяет использовать префиксы `document:on` и `window:on`.

Назначение `window:on`/`document:on` - зарегистрировать событие компонента в текущем местоположении DOM, но заставить его получать события от `window`/`document`. В этом есть два преимущества:

1. События могут быть зарегистрированы декларативно в вашем JSX;
2. События автоматически очищаются при уничтожении компонента (не требуют явной очистки).

## Хуки `useOn[window|document]`

- `useOn()`: слушает события на корневом элементе текущего компонента;
- `useOnWindow()`: слушает события на объекте `window`;
- `useOnDocument()`: слушает события на объекте `document`.

Хук `useOn[window|document]()` программно добавит слушателя событий на основе DOM на уровне компонента. Это бывает полезно при создании своих собственных хуков или если вы не знаете имя события на момент компиляции.

<CodeExample src={UseOn} sandboxStyle={{height: '10em'}}/>
