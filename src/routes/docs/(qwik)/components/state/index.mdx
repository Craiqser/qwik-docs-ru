---
title: Состояние
keywords: 'useState, state management, reactivity, reactive'
contributors:
  - nnelgxorz
  - the-r3aper7
  - voluntadpear
  - kawamataryo
  - JaymanW
  - RATIU5
  - manucorporat
  - literalpie
  - fum4
  - cunzaizhuyi
  - zanettin
  - ChristianAnagnostou
  - shairez
  - forresst
  - almilo
  - Craiqser
  - XiaoChengyin
  - gkatsanos
  - adamdbradley
  - mhevery
---
import CodeExample from '../../../../../components/code-example/index.tsx';
import CounterSignal from 'source:./example/counter-signal/index!.tsx';
import CounterStore from 'source:./example/counter-store/index!.tsx';
import CounterStoreNoTrack from 'source:./example/counter-store-no-track/index!.tsx';
import CounterStoreDeep from 'source:./example/counter-store-deep/index!.tsx';
import StorePassingProps from 'source:./example/state-passing-props/index!.tsx';
import StorePassingContext from 'source:./example/state-passing-context/index!.tsx';

# Состояние

Управление состоянием - важная часть любого приложения. В Qwik мы различаем два типа состояния - реактивное и статичное:

1. Статичное состояние - это всё, что может быть сериализовано: строка, число, объект, массив... что угодно.
2. Реактивное состояние, напротив, создаётся с помощью `useSignal()` или `useStore()`.

Важно отметить, что состояние в Qwik - это не обязательно состояние компонента, а скорее состояние приложения, которое может быть инстанцировано любым компонентом.

## `useSignal()`

Используйте `useSignal()` для создания реактивного сигнала (форма состояния). Функция `useSignal()` принимает начальное значение и возвращает реактивный сигнал.

Реактивный сигнал, возвращаемый функцией `useSignal()`, состоит из объекта с единственным свойством `.value`. Если вы измените свойство сигнала `value`, то любой компонент, который зависит от него, будет обновлён автоматически.

### Пример

Этот пример показывает, как `useSignal()` может быть использован в компоненте счётчика для отслеживания счёта.

<CodeExample src={CounterSignal} sandboxStyle={{height: '6em'}}/>

Изменение свойства `count.value` приведёт к автоматическому обновлению компонента. Например, когда свойство изменяется в обработчике нажатия кнопки, как в примере выше.

## `useStore()`

Работает аналогично `useSignal()`, но принимает объект в качестве начального значения. Можно рассматривать состояние как сигнал с несколькими значениями, или объект, состоящий из нескольких сигналов.

Используйте хук `useStore(initialStateObject)` для создания реактивного объекта. Он принимает исходный объект (или фабричную функцию) и возвращает реактивный объект.

> **ПРИМЕЧАНИЕ**
> Чтобы реактивность работала так, как ожидается, убедитесь, что сохранили ссылку на реактивный объект, а не только на его свойства. Например, написание `let { count } = useStore({ count: 0 })` и последующее изменение `count` не вызовет обновления компонентов, зависящих от этого свойства.

### Пример

Этот пример показывает, как `useStore()` можно использовать в компоненте счётчика для отслеживания счета.

<CodeExample src={CounterStore} sandboxStyle={{height: '6em'}}/>

### Рекурсивные значения

По умолчанию [`useStore()`](./index.mdx#usestore) отслеживает свойства объекта состояния только на самом верхнем уровне. Это означает, что для регистрации обновления состояния необходимо обновить значения свойств верхнего уровня.

<CodeExample src={CounterStoreNoTrack} sandboxStyle={{height: '6em'}}/>

Для того чтобы обновления были зарегистрированы стратегией отслеживания по умолчанию, мы должны обновить поле верхнего уровня `nested` следующим образом:

```ts
store.nested = { fields: { are: { 'отслеживается' } } }
```

Для того чтобы первый пример работал, мы можем передать в `useStore()` второй аргумент и указать ему использовать рекурсивное отслеживание всех свойств нашего состояния, независимо от глубины.

<CodeExample src={CounterStoreDeep} sandboxStyle={{height: '6em'}}/>

Теперь компонент будет обновляться, как и ожидалось. Это также позволит отслеживать отдельные значения внутри массивов!

## Передача состояния другим компонентам

Одной из приятных особенностей Qwik является то, что состояние можно передавать другим компонентам. Изменение состояния будет вызывать ререндер только тех компонентов, которые считывают состояние.

Существует два способа передачи состояния другим компонентам:

1. передача состояния дочернему компоненту явным образом через параметр;
2. передача состояния неявно, через контекст.

### Использование параметров

Самый простой способ передачи состояния другим компонентам - это передача через параметры.

<CodeExample src={StorePassingProps} sandboxStyle={{height: '6em'}}/>

### Использование контекста

API контекста - это способ передачи состояния компонентам без необходимости передавать его через параметры (позволяет избежать проблем с пробросом параметров). Все дочерние компоненты в дереве автоматически могут получить доступ к ссылке на состояние с возможностью чтения/записи.

Подробнее об этом можно прочитать в разделе [Контекст](./../context/index.mdx).

<CodeExample src={StorePassingContext} sandboxStyle={{height: '6em'}}/>

## Вычисляемые свойства

Вычисляемые свойства - это значения, которые получены из других значений. Они полезны, когда вам требуется значение, которое является производным от других, и вы хотите, чтобы оно с ними синхронизировалось.

В Qwik есть два способа создания вычисляемых свойств: с помощью [`useTask$()`](./../lifecycle/index.mdx#usetask) или [`useResource$()`](./../resource/index.mdx).

Основное различие между ними заключается в том, что [`useTask$()`](./../lifecycle/index.mdx#usetask) допускает побочные эффекты и выполнение сериализуется, а [`useResource$()`](./../resource/index.mdx) является асинхронным и несколько вызовов `useResource$()` могут происходить параллельно.

`useTask$()` обычно используется для вычисления промежуточного состояния, в то время как [`useResource$()`](./../resource/index.mdx) имеет лучшую эргономику для вычисления конечного состояния, используемого для рендеринга. Рассмотрим несколько примеров.

### Пример использования [`useTask$()`](./../lifecycle/index.mdx#usetask)

```tsx
import { component$, useStore, useTask$ } from '@builder.io/qwik';

export default component$(() => {
  const state = useStore({
    count: 0,
    doubleCount: 0
  });

  useTask$(({ track }) => {
    track(() => state.count);
    state.doubleCount = state.count * 2;
  });

  return (
    <>
      <button onClick$={() => state.count++}>Увеличить</button>
      Счёт: {state.count}
      Счёт * 2: {state.doubleCount}
    </>
  );
});
```

### Пример использования [`useResource$()`](./../resource/index.mdx)

```tsx
import { component$, useStore, useResource$ } from '@builder.io/qwik';

export default component$(() => {
  const state = useStore({
    count: 0,
  });

  const doubleCount = useResource$(({ track }) => {
    track(() => state.count);
    return state.count * 2;
  });

  return (
    <>
      <button onClick$={() => state.count++}>Увеличить</button>
      Счёт: {state.count}
      Счёт * 2: {doubleCount.promise}
    </>
  );
});
```

Как [`useTask()`](./../lifecycle/index.mdx#usetask), так и [`useResource()`](./../resource/index.mdx) подробно описаны в соответствующих разделах.

## Реактивность

Благодаря фрагментарной реактивности Qwik, обновляться будут только те компоненты, которые зависят от состояния. Это огромный выигрыш в производительности, так как обновляются только те компоненты, которые действительно необходимо обновить.

## `noSerialize()`

Иногда вы можете захотеть сохранить значение в состоянии, но не хотите, чтобы оно было сериализовано. Это полезно для хранения значений, которые не являются сериализуемыми, например, функций или классов.

```tsx
import { component$, useStore, noSerialize, useVisibleTask$ } from '@builder.io/qwik';

export const App = component$(() => {
  const state = useStore({
    monacoInstance: null
  });

  useVisibleTask$(() => {
    // Monaco не является сериализуемым, поэтому мы не можем хранить его в состоянии, не используя `noSerialize()`.
    state.monacoInstance = noSerialize(new Monaco());
  });
  return <></>;
});
```
