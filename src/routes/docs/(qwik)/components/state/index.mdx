---
title: Состояние
keywords: 'useState, state management, reactivity, reactive'
contributors:
  - nnelgxorz
  - the-r3aper7
  - voluntadpear
  - kawamataryo
  - JaymanW
  - RATIU5
  - manucorporat
  - literalpie
  - fum4
  - cunzaizhuyi
  - zanettin
  - ChristianAnagnostou
  - shairez
  - forresst
  - almilo
  - Craiqser
  - XiaoChengyin
  - gkatsanos
  - adamdbradley
  - mhevery
---

import CodeSandbox from '../../../../../components/code-sandbox/index.tsx';

# Состояние

Управление состоянием - важная часть любого приложения. В Qwik мы различаем два типа состояния - реактивное и статичное:

1. Статичное состояние - это всё, что может быть сериализовано: строка, число, объект, массив... что угодно.
2. Реактивное состояние, напротив, создаётся с помощью `useSignal()` или `useStore()`.

Важно отметить, что состояние в Qwik - это не обязательно состояние компонента, а скорее состояние приложения, которое может быть инстанцировано любым компонентом.

## `useSignal()`

Используйте `useSignal()` для создания реактивного сигнала (форма состояния). Функция `useSignal()` принимает начальное значение и возвращает реактивный сигнал.

Реактивный сигнал, возвращаемый функцией `useSignal()`, состоит из объекта с единственным свойством `.value`. Если вы измените свойство сигнала `value`, то любой компонент, который зависит от него, будет обновлён автоматически.

<CodeSandbox src="/src/routes/demo/state/counter-signal/index.tsx" style={{ height: '6em' }}>
```tsx {4} /count/
import { component$, useSignal } from '@builder.io/qwik';

export default component$(() => {
  const count = useSignal(0);

  return (
    <button onClick$={() => count.value++}>
      Прибавить {count.value}
    </button>
  );
});
```
</CodeSandbox>

Приведённый выше пример показывает, как может быть использован `useSignal()` в компоненте счётчика для отслеживания счёта. Изменение свойства `count.value` приведёт к автоматическому обновлению компонента. Например, когда свойство изменяется в обработчике нажатия кнопки, как в примере выше.

## `useStore()`

Работает аналогично `useSignal()`, но принимает объект в качестве начального значения. Можно рассматривать состояние как сигнал с несколькими значениями, или объект, состоящий из нескольких сигналов.

Используйте хук `useStore(initialStateObject)` для создания реактивного объекта. Он принимает исходный объект (или фабричную функцию) и возвращает реактивный объект.

> **ПРИМЕЧАНИЕ**
> Чтобы реактивность работала так, как ожидается, убедитесь, что сохранили ссылку на реактивный объект, а не только на его свойства. Например, написание `let { count } = useStore({ count: 0 })` и последующее изменение `count` не вызовет обновления компонентов, зависящих от этого свойства.

<CodeSandbox src="/src/routes/demo/state/counter-store/index.tsx" style={{ height: '6em' }} >
```tsx {4} /state/ /count/#a
import { component$, useStore } from '@builder.io/qwik';

export default component$(() => {
  const state = useStore({ count: 0 });

  return (
    <>
      <button onClick$={() => state.count++}>Прибавить</button>
      <div>Счётчик: {state.count}</div>
    </>
  );
});
```
</CodeSandbox>

Приведённый выше пример показывает, как можно использовать `useStore()` в компоненте счётчика для отслеживания счёта.

### Рекурсивные значения

По умолчанию [`useStore()`](./index.mdx#usestore) отслеживает свойства объекта состояния только на самом верхнем уровне. Это означает, что для регистрации обновления состояния необходимо обновить значения свойств верхнего уровня.

<CodeSandbox src="/src/routes/demo/state/counter-store-no-track/index.tsx" style={{ height: '10em' }}>
```tsx
import { component$, useStore } from '@builder.io/qwik';

export default component$(() => {
  const store = useStore({
    nested: { fields: { are: 'не отслеживается' } },
  });

  return (
    <>
      <p>{store.nested.fields.are}</p>
      <button onClick$={() => (store.nested.fields.are = 'отслеживается')}>
        Нажми меня - не работает
      </button>
      <br />
      <button onClick$={() => (store.nested = { fields: { are: 'отслеживается' } })}>
        Нажми меня - работает
      </button>
    </>
  );
});
```
</CodeSandbox>

Для того чтобы обновления были зарегистрированы стратегией отслеживания по умолчанию, мы должны обновить поле верхнего уровня `nested` следующим образом:

```ts
store.nested = { fields: { are: { 'отслеживается' } } }
```

Для того чтобы первый пример работал, мы можем передать в `useStore()` второй аргумент и указать ему использовать рекурсивное отслеживание всех свойств нашего состояния, независимо от глубины.

<CodeSandbox src="/src/routes/demo/state/counter-store-deep/index.tsx" style={{ height: '10em' }}>
```tsx
import { component$, useStore } from '@builder.io/qwik';

export default component$(() => {
  const store = useStore(
    {
      nested: { fields: { are: 'не отслеживается' } },
    },
    { deep: true }
  );

  return (
    <>
      <p>{store.nested.fields.are}</p>
      <button onClick$={() => (store.nested.fields.are = 'отслеживается')}>
        Нажми меня - работает, потому что состояние отслеживается на всю глубину вложенности
      </button>
      <br />
      <button onClick$={() => (store.nested = { fields: { are: 'отслеживается' } })}>
        Нажми меня - всё ещё работает
      </button>
    </>
  );
});
```
</CodeSandbox>

Теперь компонент будет обновляться, как и ожидалось. Это также позволит отслеживать отдельные значения внутри массивов!

## Вычисленное состояние

Вычисленное состояние получается из существующего состояния.

В Qwik есть два способа создания вычисляемых свойств, каждый из которых имеет свой сценарий использования (в порядке предпочтения):

1. `useComputed$()`: `useComputed$()` является предпочтительным способом создания вычисляемых свойств. Используйте его, когда вычисляемое свойство может быть получено синхронно исключительно из исходного состояния (текущего состояния приложения). Например, создание строки из строчных букв или объединение имени и фамилии в полное имя.
2. [`useResource$()`](/docs/(qwik)/components/resource/index.mdx): `useResource$()` используется, когда вычисляемое свойство является асинхронным или состояние приходит извне приложения. Например, получение текущей погоды (внешнее состояние) на основе текущего местоположения (внутреннее состояние приложения).

Вышеописанное можно представить так: они наблюдают за существующим состоянием, и когда состояние меняется, вычисленное значение пересчитывается. Результатом является новое вычисленное значение, которое является сигналом, возвращаемым из `useComputed$()` или `useResource$()`.

Помимо двух описанных выше способов создания вычисляемых свойств, существует также более низкоуровневый ([`useTask$()`](/docs/(qwik)/components/tasks/index.mdx#usetask) и [`useVisibleTask$()`](/docs/components/tasks/#usevisibletask)) способ модификации/создания состояния в результате изменения входа. Этот способ не производит новый сигнал, а скорее изменяет существующее состояние или производит побочный эффект.

### `useComputed$()`

Используйте `useComputed$` для создания вычисляемого значения, которое может быть получено синхронно из существующего состояния приложения.

<CodeSandbox src="/src/routes/demo/state/computed/index.tsx" style={{ height: '8em' }}>
```tsx {5} /useComputed$/
import { component$, useComputed$, useSignal } from '@builder.io/qwik';

export default component$(() => {
  const name = useSignal('Qwik');
  const capitalizedName = useComputed$(() => name.value.toUpperCase());

  return (
    <>
      <input type="text" bind:value={name} />
      <div>Name: {name.value}</div>
      <div>Capitalized name: {capitalizedName.value}</div>
    </>
  );
});
```
</CodeSandbox>

> **ПРИМЕЧАНИЕ** Поскольку `useComputed$()` является синхронным, нет необходимости в явном отслеживании входных сигналов.

### `useResource$()`

Используйте `useResource$()` для создания вычисляемого значения, которое выводится асинхронно или требует внешнего состояния (например, обращения к конечной точке REST).

<CodeSandbox src="/src/routes/demo/state/resource/index.tsx" style={{ height: '8em' }}>
```tsx {11} /useResource$/
import {
  component$,
  Resource,
  useResource$,
  useSignal,
} from '@builder.io/qwik';

export default component$(() => {
  const prNumber = useSignal('3576');

  const prTitle = useResource$(async ({ track }) => {
    track(() => prNumber); // Requires explicit tracking of inputs
    const response = await fetch(
      `https://api.github.com/repos/BuilderIO/qwik/pulls/${prNumber.value}`
    );
    const data = await response.json();
    return (data.title || data.message || 'Error') as string;
  });

  return (
    <>
      <input type="number" bind:value={prNumber} />
      <h1>
        PR#{prNumber}:
        <Resource
          value={prTitle}
          onPending={() => <>Загрузка...</>}
          onResolved={(title) => <>{title}</>}
        />
      </h1>
    </>
  );
});
```
</CodeSandbox>

Можно использовать `useResource$()` без компонента `<Resource>`, но это не так удобно. Компонент `<Resource>` автоматически показывает предоставленное резервное содержимое во время вычисления ресурса.

> **ПРИМЕЧАНИЕ**: во время SSR компонент `<Resource>` приостанавливает рендер до тех пор, пока ресурс не будет разрешён. Таким образом, SSR не будет отображать индикатор загрузки.

## Передача состояния

Одной из приятных особенностей Qwik является то, что состояние можно передавать другим компонентам. Изменение состояния будет вызывать ререндер только тех компонентов, которые считывают состояние.

Существует два способа передачи состояния другим компонентам:

1. передача состояния дочернему компоненту явным образом через параметр;
2. передача состояния неявно, через контекст.

### Использование параметров

Самый простой способ передачи состояния другим компонентам - это передача через параметры.

<CodeSandbox src="/src/routes/demo/state/passing-props/index.tsx" style={{ height: '6em' }}>
```tsx {9} /userData=/
import { component$, useStore } from '@builder.io/qwik';

export default component$(() => {
  const userData = useStore({ count: 0 });
  return <Child userData={userData} />;
});

interface ChildProps {
  userData: { count: number };
}
export const Child = component$<ChildProps>(({ userData }) => {
  return (
    <>
      <button onClick$={() => userData.count++}>Прибавить</button>
      <div>Счётчик: {userData.count}</div>
    </>
  );
});
```
</CodeSandbox>

### Использование контекста

API контекста - это способ передачи состояния компонентам без необходимости передавать его через параметры (позволяет избежать проблем с пробросом параметров). Все дочерние компоненты в дереве автоматически могут получить доступ к ссылке на состояние с возможностью чтения/записи.

Подробнее об этом можно прочитать в разделе [Контекст](./../context/index.mdx).

<CodeSandbox src="/src/routes/demo/state/passing-context/index.tsx" style={{ height: '6em' }}>
```tsx /userData/ /export const CTX = createContextId<{ count: number }>('stuff');/ /useContextProvider(CTX, userData);/ /const userData = useContext(CTX);/
import {
  component$,
  createContextId,
  useContext,
  useContextProvider,
  useStore,
} from '@builder.io/qwik';

// Объявление идентификатора контекста
export const CTX = createContextId<{ count: number }>('stuff');

export default component$(() => {
  const userData = useStore({ count: 0 });

  // Предоставляем состояние контексту по идентификатору контекста
  useContextProvider(CTX, userData);

  return <Child />;
});

export const Child = component$(() => {
  const userData = useContext(CTX);
  return (
    <>
      <button onClick$={() => userData.count++}>Прибавить</button>
      <div>Счётчик: {userData.count}</div>
    </>
  );
});
```
</CodeSandbox>

## `noSerialize()`

Qwik гарантирует, что всё состояние приложения всегда сериализуемо. Это важно для того, чтобы приложения Qwik имели свойство [возобновляемости](/docs/(qwik)/concepts/resumable/index.mdx). Иногда необходимо хранить данные, которые не могут быть сериализованы. Например, ссылку на стороннюю библиотеку, такую ​​как [редактор Monaco](https://microsoft.github.io/monaco-editor/). В такой ситуации используйте `noSerialize()`, чтобы пометить значение как несериализуемое.

Если значение помечено как несериализуемое, то это значение не подвергается событиям сериализации, таким как возобновление работы приложения на клиенте с сервера SSR. В такой ситуации значение будет установлено в `undefined`, и разработчик должен повторно инициализировать значение на клиенте.

<CodeSandbox src="/src/routes/demo/state/no-serialize/index.tsx" style={{ height: '8em' }}>
```tsx /noSerialize/
import {
  component$,
  useStore,
  noSerialize,
  useVisibleTask$,
} from '@builder.io/qwik';
import Monaco from './monaco';

export default component$(() => {
  const store = useStore<{ monacoInstance: Monaco | undefined }>({
    // Не инициализировать на сервере
    monacoInstance: undefined,
  });

  useVisibleTask$(() => {
    // Monaco является несериализуемым объектом, поэтому мы не можем сериализовать его во время SSR.
    // Однако мы можем инстанцировать его на клиенте после того, как компонент станет видимым.
    setTimeout(() => (store.monacoInstance = noSerialize(new Monaco())), 1000);
  });
  return <div>{store.monacoInstance ? 'Monaco загружен' : 'загрузка...'}</div>;
});
```
</CodeSandbox>
