---
title: Обзор
contributors:
  - RATIU5
  - leifermendez
  - manucorporat
  - adamdbradley
  - cunzaizhuyi
  - shairez
  - the-r3aper7
  - zanettin
  - Craiqser
  - steve8708
  - mforncro
  - georgeiliadis91
  - leader22
  - almilo
  - estherbrunner
  - kumarasinghe
  - mhevery
---
import CodeExample from '../../../../../components/code-example/index.tsx';
import SimpleComponent from 'source:/src/routes/demo/component/simple/index.tsx';
import TwoComponents from 'source:/src/routes/demo/component/child/index.tsx';
import Counter from 'source:/src/routes/demo/state/counter/index.tsx';
import Props from 'source:/src/routes/demo/component/props/index.tsx';
import Ref from 'source:/src/routes/demo/component/ref/index.tsx';
import Lazy from 'source:/src/routes/demo/component/lazy/index.tsx';
import InlineChild from 'source:/src/routes/demo/component/inline-child/index.tsx';

# Компоненты

Компоненты - это базовые строительные блоки приложений Qwik. Компоненты Qwik уникальны в своём роде:

- Компоненты Qwik автоматически разбиваются [оптимизатором](../../advanced/optimizer/index.mdx) на лениво загружаемые фрагменты;
- Они являются [возобновляемыми](../../concepts/resumable/index.mdx) (компонент может быть создан на сервере и продолжать выполняться на клиенте);
- Они являются [реактивными](../../concepts/reactivity/index.mdx) и рендерятся независимо от других компонентов на странице. См. описание [рендера](../../components/rendering/index.mdx).

## `component$()`

Компонент - это небольшой, переиспользуемый фрагмент кода, который можно использовать для создания пользовательского интерфейса.

В Qwik они объявляются с помощью метода `component$`:

<CodeExample src={SimpleComponent} sandboxStyle={{height: '3em'}}/>

> Причина написания `component$` в том, что последующий `$` позволяет [оптимизатору](/docs/advanced/dollar/) разбивать компоненты в дереве приложения на отдельные чанки, так что каждый чанк может быть загружен (или не загружен, если он не нужен) независимо. Без знака `$` компонент будет загружаться всегда, если необходимо загрузить родительский компонент.

### Композиция компонентов

Компоненты можно компоновать друг с другом для создания более сложных компонентов.

<CodeExample src={TwoComponents} sandboxStyle={{height: '6em'}}/>

### Пример счётчика

Несколько более сложный пример счётчика.

<CodeExample src={Counter} sandboxStyle={{height: '6em'}}/>

## Параметры

Параметры используются для передачи данных в компонент. Параметры объявляются как именованные аргументы компонента.

В этом примере компонент `Item` объявляет необязательные параметры `name`, `quantity`, `description` и `price`.

<CodeExample src={Props} sandboxStyle={{height: '10em'}}/>

## Реактивный ререндер

Компоненты Qwik являются реактивными. Это означает, что они автоматически обновляются при изменении состояния. Существует два вида обновлений:

1. Состояние привязывается к тексту или атрибуту DOM. Такие изменения обычно напрямую обновляют DOM и не требуют повторного выполнения функции компонента.
2. Состояние вызывает структурные изменения в DOM (элементы создаются и или удаляются). Такие изменения требуют повторного выполнения функции компонента.

Следует помнить, что при изменении состояния функция вашего компонента может выполняться ноль или более раз в зависимости от того, к чему привязано состояние. По этой причине функция должна быть идемпотентной, и вы не должны полагаться на количество раз ее выполнения.

Изменение состояния приводит к тому, что компонент становится недействительным. Когда компоненты признаются недействительными, они добавляются в очередь обновлений, которая очищается (рендерится) при очередном событии `requestAnimationFrame`. Очередь служит для объеденения рендера компонентов.

## Получение элемента DOM

Используйте `ref` для получения элемента DOM. Сначала создайте сигнал для хранения элемента DOM и затем передайте его в свойство JSX `ref`.

<CodeExample src={Ref} sandboxStyle={{height: '10em'}}/>

## Ленивая загрузка

Компонент также играет важную роль в разрыве отношений родитель-потомок в целях разбиения на чанки.

```tsx
export const Child = () => <span>child</span>;

const Parent = () => (
  <section>
    <Child />
  </section>
);
```

В приведённом выше примере обращение к компоненту `Parent` подразумевает транзитивную ссылку на компонент `Child`. Когда упаковщик создаёт чанк, ссылка на `Parent` также требует упаковки `Child` (внутри `Parent` есть зависимость на `Child`). Эти транзитивные зависимости представляют из себя проблему, так как это означает, что наличие ссылки на корневой компонент приложения будет транзитивно тянуть остальную часть приложения, чего Qwik пытается избежать.

Чтобы избежать описанной выше проблемы, мы не ссылаемся на компоненты напрямую, вместо этого мы ссылаемся на ленивую обёртку. Она создаётся автоматически функцией `component$()`.

<CodeExample src={Lazy} sandboxStyle={{height: '10em'}} sandbox={false}/>

Для приведённого выше примера оптимизатор выполнит следующее преобразование кода:

```tsx
const Child = componentQrl(qrl('./chunk-a', 'Child_onMount'));
const Parent = componentQrl(qrl('./chunk-b', 'Parent_onMount'));
const Parent_onMount = () => qrl('./chunk-c', 'Parent_onRender');
const Parent_onRender = () => (
  <section>
    <Child />
  </section>
);
```

> **ПРИМЕЧАНИЕ**
> Для простоты показаны не все преобразования. Результирующие символы хранятся для краткости в одном файле.

Обратите внимание, что после того, как оптимизатор преобразовал код, `Parent` больше не ссылается напрямую на `Child`. Это важно, потому что позволяет упаковщику свободно перемещать символы в разные бандлы, не увлекая за собой остальную часть приложения.

Что же происходит, когда компоненту `Parent` нужно отрендерить компонент `Child`, но компонент `Child` ещё не загружен? Во-первых, компонент `Parent` отображает свой DOM следующим образом:

```html
<div>
  <section>
    <!--qv--><!--/qv-->
  </section>
</div>
```

Как видно из приведённого выше примера, `<!--qv-->` действует как маркер, куда будет вставлен компонент `Child` после того, как он будет лениво загружен.

## Встроенные компоненты

В дополнение к стандартному `component$()`, со всеми его свойствами ленивой загрузки, Qwik также поддерживает облегчённые (встроенные) компоненты, которые больше похожи на традиционные фреймворки. Встроенные компоненты также называют инлайновыми компонентами.

<CodeExample src={InlineChild} sandboxStyle={{height: '4em'}}/>

В приведённом выше примере `MyButton` является встроенным компонентом. В отличие от стандартного `component$()`, встроенные компоненты не могут быть лениво загружены индивидуально, они объединяются со своим родительским компонентом. В данном случае:

- `MyButton` будет связан с компонентом `default`;
- Всякий раз, когда выполняется функция рендера `default`, она гарантированно вызывает выполнение рендера `MyButton`;

Можно считать, что они встраиваются в компонент, в котором инстанцируются.

## Ограничения

Встроенные компоненты имеют некоторые ограничения, отсутствующие у стандартного `component$()`:

- Невозможно использовать `use`-методы, такие как `useSignal` или `useStore`.

Как и следует из их названия, встроенные компоненты лучше экономно использовать для легковесных фрагментов разметки, поскольку их удобство в том, что они связаны с родительским компонентом.

## Обзор API

### Состояние

- [`useSignal(initialState)`](../state/index.mdx#usesignal) - создает реактивное значение
- [`useStore(initialStateObject)`](../state/index.mdx#usestore) - создает реактивный объект, который может быть использован для хранения состояния
- [`createContextId(contextName)`](../context/index.mdx#createcontext) - создает ссылку контекста
- [`useContextProvider()`](../context/index.mdx#usecontextprovider) - предоставляет значение данного контекста
- [`useContext()`](../context/index.mdx#usecontext) - считывает значение текущего контекста

### Стили

- [`useStylesScoped$()`](../styles/index.mdx#usestylesscoped) - добавляет стили к текущему экземпляру компонента
- [`useStyles$()`](../styles/index.mdx#usestyles) - добавляет стили к текущему компоненту

### События

- [`useOn()`](../events/index.mdx) - программно добавляет слушателя к текущему компоненту
- [`useOnWindow()`](../events/index.mdx) - программно добавляет слушателя к объекту window
- [`useOnDocument()`](../events/index.mdx) - программно добавляет слушателя к объекту document

### Задачи/Жизненный цикл

- [`useTask$()`](../tasks/index.mdx#usetask) - определяет функцию обратного вызова, которая будет вызываться перед рендером и/или при изменении наблюдаемого хранилища;
- [`useVisibleTask$()`](../tasks/index.mdx#usevisibletask) - определяет функцию обратного вызова, которая будет выполняться после рендера, только в браузере.
- [`useResource$()`](../task/index.mdx#useresource) - создаёт ресурс для асинхронной загрузки данных;

### Другое

- [`$()`](../../advanced/qrl/index.mdx) - создаёт QRL
- `noSerialize()`
- `useErrorBoundary()`

### Компоненты

- [`<Slot>`](../projection/index.mdx) - объявляет слот для отображения контента
- `<SSRStreamBlock>` - объявляет блок потока
- `<SSRStream>` - объявляет поток
- `<Fragment>` - объявляет JSX-фрагмент

## См. также

- [Встроенные компоненты](../overview/index.mdx#inline-components)
