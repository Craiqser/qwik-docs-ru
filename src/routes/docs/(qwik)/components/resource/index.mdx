---
title: Ресурсы
keywords: 'data fetching, loading, data, fetch'
contributors:
  - nnelgxorz
  - irfanullahjan
  - RATIU5
  - manucorporat
  - the-r3aper7
  - cunzaizhuyi
  - runarj
  - zanettin
  - TejasQ
  - gederer
  - forresst
  - adamdbradley
---

# useResource$()

Этот хук позволяет вам асинхронно генерировать вычисляемые значения, обычно используемые для получения внешних данных (ресурсов). Хук вызывается при монтировании компонента (и при изменении отслеживаемых значений). Хук `useResource$` предназначен для использования с компонентом `<Resource />`. Компонент `<Resource />` - это удобный способ для отображения состояний ресурса, таких как loaded (загружен), resolved (разрешён), или rejected (отклонён).

Важно понимать, что `useResource$` выполняется при первоначальном рендере компонента (как и `useTask$`). Иногда бывает желательно начать получать данные на сервере как часть процесса SSR до того, как компонент будет отрендерен. Получение данных как часть процесса SSR является более распространённым и предпочтительным способом загрузки данных вместо выполнения через API [`routeLoader$`](/docs/(qwikcity)/route-loader/index.mdx). `useResource$` - это более низкоуровневый API, который полезен, когда вы хотите получить данные на клиенте.

> Как и все `use-`хуки, он должен вызываться в контексте [`component$()`](/docs/(qwik)/components/overview/index.mdx#component), при этом применяются все правила [использования use-методов](/docs/(qwik)/components/lifecycle/index.mdx#правила-использования-use-методов).
>
> Во многих отношениях `useResource$` похож на `useTask$`. Большое различие заключаются в следующем:
>
> - `useResource$` позволяет вам возвращать "значение";
> - `useResource$` не блокирует рендер, пока ресурс находится в процессе получения.
>
> Смотри раздел [`routeLoader$`](/docs/(qwikcity)/route-loader/index.mdx) для получения данных как часть SSR-процесса.

## Пример

Давайте начнем с простого примера, который будет получать шутки при первоначальном рендере компонента.

```tsx
import { component$, useResource$, Resource } from '@builder.io/qwik';

interface Joke {
  value: string;
}

export default component$(() => {
  const joke = useResource$(async () => {
    const resp = await fetch('https://api.chucknorris.io/jokes/random');
    return (await resp.json()) as Joke;
  });
  return (
    <>
      <Resource
        value={joke}
        onPending={() => <>загрузка...</>}
        onResolved={(joke) => <div>{joke.value}</div>}
      />
    </>
  );
});
```

## `track()`

Часто возникает необходимость повторной выборки ресурса при изменении некоторых входных данных.

Вот очень простой пример использования `useResource$()` для получения случайной шутки:

```tsx
import { component$, useResource$, Resource } from '@builder.io/qwik';

export default component$(() => {
  const jokes = useResource$(async () => {
    const resp = await fetch('https://api.chucknorris.io/jokes/random');
    return resp.json();
  });

  return (
    <Resource
      value={jokes}
      onPending={() => <div>загрузка...</div>}
      onResolved={(joke) => (
        <div>{joke.value}</div>
      )}
    />
  );
});
```

И более сложный пример, демонстрирующий больше возможностей. В этом примере будет получен список анекдотов на основе запроса, введённого пользователем,
автоматическое реагирование на изменения в запросе, включая прерывание запроса, который выполняется в данный момент.

```tsx
import {
  component$,
  useResource$,
  Resource,
  useSignal,
} from '@builder.io/qwik';

export default component$(() => {
  const query = useSignal('busy');
  const jokes = useResource$(async ({ track, cleanup }) => {
    track(query);
    // Использование `AbortController` является хорошей практикой для прерывания получения данных, если
    // поступает новый запрос. Мы создаем новый `AbortController` и регистрируем функцию `cleanup`,
    // которая вызывается при перезапуске запроса.
    const controller = new AbortController();
    cleanup(() => controller.abort());

    if (query.value.length < 3) {
      return [];
    }

    const url = new URL('https://api.chucknorris.io/jokes/search');
    url.searchParams.set('query', query.value);

    const resp = await fetch(url, { signal: controller.signal });
    const json = (await resp.json()) as { result: { value: string }[] };

    return json.result;
  });

  return (
    <>
      Запрос: <input bind:value={query} />
      <button>поиск</button>
      <Resource
        value={jokes}
        onPending={() => <>загрузка...</>}
        onResolved={(jokes) => (
          <ul>
            {jokes.map((joke) => (
              <li>{joke.value}</li>
            ))}
          </ul>
        )}
      />
    </>
  );
});
```

Как мы видим в приведённом выше примере, `useResource$()` возвращает объект `ResourceReturn<T>`, который работает как полностью реактивный промис, содержащий данные и состояние ресурса.

Состоянием `resource.loading` может быть одна из следующих строк:

- `false` - данные ещё не доступны;
- `true` - данные доступны (промис либо разрешён, либо отклонён).

Функция обратного вызова, переданная в [`useResource$()`](./index.mdx), запускается сразу после завершения обратного вызова [`useTask$()`](./../lifecycle/index.mdx#usetask). Дополнительные сведения смотри в разделе [Жизненный цикл](./../lifecycle/index.mdx).

## `<Resource />`

`<Resource />` - это компонент, предназначенный для использования с функцией `useResource$()`, и который отображает различное содержимое в зависимости от статуса ресурса: pending (выполняется), resolved (разрешён), или rejected (отклонён).

```tsx
<Resource
  value={weatherResource}
  onPending={() => <div>Загрузка...</div>}
  onRejected={() => <div>Не удалось загрузить данные о погоде</div>}
  onResolved={(weather) => {
    return <div>Температура: {weather.temp}</div>;
  }}
/>
```

Стоит отметить, что `<Resource />` не требуется при использовании `useResource$()`. Это просто удобный способ отображения состояния ресурса.

### Примеры:

- #### [`useResource$()`](./index.mdx) с `<Resource />`

Данный пример показывает использование `useResource$` для выполнения запроса к API agify.io. Он позволяет определить возраст человека на основе имени, введённого пользователем, и будет обновляться всякий раз, когда пользователь вводит новое имя.

```tsx
import {
  component$,
  useSignal,
  useResource$,
  Resource,
} from '@builder.io/qwik';

export default component$(() => {
  const name = useSignal<string>();

  const ageResource = useResource$<{
    name: string;
    age: number;
    count: number;
  }>(async ({ track, cleanup }) => {
    track(() => name.value);
    const abortController = new AbortController();
    cleanup(() => abortController.abort('cleanup'));
    const res = await fetch(`https://api.agify.io?name=${name.value}`, {
      signal: abortController.signal,
    });
    return res.json();
  });

  return (
    <div>
      <h1>Введите своё имя, и я угадаю ваш возраст!</h1>
      <input
        onInput$={(e: Event) =>
          (name.value = (e.target as HTMLInputElement).value)
        }
      />
      <Resource
        value={ageResource}
        onPending={() => <div>Загрузка...</div>}
        onRejected={() => <div>Не удалось получить данные</div>}
        onResolved={(ageGuess) => {
          return (
            <div>
              {name.value && (
                <>
                  {ageGuess.name} {ageGuess.age} years
                </>
              )}
            </div>
          );
        }}
      />
    </div>
  );
});
```
