---
title: Ресурсы
keywords: 'data fetching, loading, data, fetch'
contributors:
  - nnelgxorz
  - irfanullahjan
  - RATIU5
  - manucorporat
  - the-r3aper7
  - cunzaizhuyi
  - runarj
  - zanettin
  - TejasQ
  - gederer
  - forresst
  - adamdbradley
---

# useResource$()

Этот метод позволяет асинхронно создавать вычисляемые значения. Асинхронная функция, переданная в качестве первого параметра, будет вызываться при монтировании компонента и изменении отслеживаемых значений.

Как и все `use`-методы использования, он должен вызываться в контексте [`component$()`](/docs/(qwik)/components/overview/index.mdx#component), с соблюдением всех [правил хука](/docs/(qwik)/components/lifecycle/index.mdx#правила-использования-метода-use).

```tsx
import {
  component$,
  useResource$,
  Resource,
  useSignal,
} from '@builder.io/qwik';

export default component$(() => {
  const query = useSignal('busy');
  const jokes = useResource$<{ value: string }[]>(
    async ({ track, cleanup }) => {
      track(query);
      // Использование `AbortController` является хорошей практикой для прерывания получения данных, если
      // поступает новый запрос. Мы создаем новый `AbortController` и регистрируем функцию `cleanup`,
      // которая вызывается при перезапуске запроса.
      const controller = new AbortController();
      cleanup(() => controller.abort());

      if (query.value.length < 3) return [];
      const url = new URL('https://api.chucknorris.io/jokes/search');
      url.searchParams.set('query', query.value);
      const resp = await fetch(url, { signal: controller.signal });
      const json = (await resp.json()) as { result: { value: string }[] };
      return json.result;
    }
  );
  return (
    <>
      Запрос: <input bind:value={query} />
      <button>поиск</button>
      <Resource
        value={jokes}
        onPending={() => <>загрузка...</>}
        onResolved={(jokes) => (
          <ul>
            {jokes.map((joke) => (
              <li>{joke.value}</li>
            ))}
          </ul>
        )}
      />
    </>
  );
});
```

Как мы видим в приведённом выше примере, `useResource$()` возвращает объект `ResourceReturn<T>`, который работает как полностью реактивный промис, содержащий данные и состояние ресурса.

Состоянием `resource.loading` может быть одна из следующих строк:

- `false` - данные ещё не доступны;
- `true` - данные доступны (промис либо разрешён, либо отклонён).

Функция обратного вызова, переданная в [`useResource$()`](./index.mdx), запускается сразу после завершения обратного вызова [`useTask$()`](./../lifecycle/index.mdx#usetask). Дополнительные сведения смотри в разделе [Жизненный цикл](./../lifecycle/index.mdx).

## `<Resource />`

`<Resource />` - это компонент, предназначенный для использования с функцией `useResource$()`, и который отображает различное содержимое в зависимости от статуса ресурса: pending (выполняется), resolved (разрешён), или rejected (отклонён).

```tsx
<Resource
  value={weatherResource}
  onPending={() => <div>Загрузка...</div>}
  onRejected={() => <div>Не удалось загрузить данные о погоде</div>}
  onResolved={(weather) => {
    return <div>Температура: {weather.temp}</div>;
  }}
/>
```

Стоит отметить, что `<Resource />` не требуется при использовании `useResource$()`. Это просто удобный способ отображения состояния ресурса.

### Примеры:

- #### [`useResource$()`](./index.mdx) с `<Resource />`

Данный пример показывает использование `useResource$` для выполнения запроса к API agify.io. Он позволяет определить возраст человека на основе имени, введённого пользователем, и будет обновляться всякий раз, когда пользователь вводит новое имя.

```tsx
import {
  component$,
  useSignal,
  useResource$,
  Resource,
} from '@builder.io/qwik';

export default component$(() => {
  const name = useSignal<string>();

  const ageResource = useResource$<{
    name: string;
    age: number;
    count: number;
  }>(async ({ track, cleanup }) => {
    track(() => name.value);
    const abortController = new AbortController();
    cleanup(() => abortController.abort('cleanup'));
    const res = await fetch(`https://api.agify.io?name=${name.value}`, {
      signal: abortController.signal,
    });
    return res.json();
  });

  return (
    <div>
      <h1>Введите своё имя, и я угадаю ваш возраст!</h1>
      <input
        onInput$={(e: Event) =>
          (name.value = (e.target as HTMLInputElement).value)
        }
      />
      <Resource
        value={ageResource}
        onPending={() => <div>Загрузка...</div>}
        onRejected={() => <div>Не удалось получить данные</div>}
        onResolved={(ageGuess) => {
          return (
            <div>
              {name.value && (
                <>
                  {ageGuess.name} {ageGuess.age} years
                </>
              )}
            </div>
          );
        }}
      />
    </div>
  );
});
```
