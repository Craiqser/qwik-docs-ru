---
title: События
contributors:
  - mhevery
---
import CodeExample from '../../../../../components/code-example/index.tsx';
import UseTask from 'source:/src/routes/demo/tasks/use-task/index.tsx';
import Track from 'source:/src/routes/demo/tasks/track/index.tsx';
import TrackServerGuard from 'source:/src/routes/demo/tasks/track-server-guard/index.tsx';
import TrackFn from 'source:/src/routes/demo/tasks/track-fn/index.tsx';
import Cleanup from 'source:/src/routes/demo/tasks/cleanup/index.tsx';
import UseVisibleTask from 'source:/src/routes/demo/tasks/use-visible-task/index.tsx';
import UseVisibleTaskEager from 'source:/src/routes/demo/tasks/use-visible-task-eager/index.tsx';

# Задачи

Задачи предназначены для выполнения асинхронных операций в рамках инициализации компонента или изменения его состояния.

> **Примечание**: Задачи похожи на хук `useEffect()` в React, но различий достаточно, чтобы мы не хотели называть их одинаково, чтобы не привносить заранее сложившиеся ожидания о том, как они работают. Основными отличиями являются:
> - Задачи являются асинхронными;
> - Задача выполняется на сервере и клиенте;
> - Задачи выполняются до рендера и могут блокировать рендер.

`useTask$()` должен быть вашим стандартным API для запуска асинхронной (или синхронной) работы в рамках инициализации компонента или изменения состояния. Только когда вы не можете достичь желаемого с помощью `useTask$()`, вы должны рассмотреть возможность использования `useVisibleTask$()` или `useResource$()`.

Основным вариантом использования `useTask$()` является выполнение работы по инициализации компонента. `useTask$()` имеет такие свойства:
- Он работает на сервере и на клиенте;
- Он запускается перед рендером и блокирует рендер;
- Если запущено несколько задач, то они выполняются последовательно в порядке их регистрации. Асинхронная задача будет блокировать выполнение следующей задачи до тех пор, пока она не завершится.

Задачи также можно использовать для выполнения работы при изменении состояния компонента. В этом случае задача будет выполняться заново каждый раз, когда отслеживаемое состояние изменится. Смотри главу [`track()`](#track).

Иногда задача должна выполняться только на клиенте и после рендера, в этом случае следует использовать [`useVisibleTask$()`](#usevisibletask).

Иногда задача должна получать данные асинхронно и создавать сигнал (а не блокировать рендер), в этом случае следует использовать [`useResource$()`](#useresource).

## `useTask$()`

Рассмотрим простейший вариант использования задачи для выполнения асинхронной работы по инициализации компонента.

<CodeExample src={UseTask} sandboxStyle={{height: '6em'}}/>

> В данном примере
> - Функция `useTask$()` вычисляет число Фибоначчи по одной записи за 100 мс. Таким образом, 40 записей занимают 4 секунды.
> - `useTask$()` выполняется на сервере как часть SSR (результат может быть кэширован в CDN).
> - Поскольку `useTask$()` блокирует рендер, рендер HTML-страницы занимает 4 секунды.
> - Поскольку у этой задачи нет `track()`, она никогда не будет выполняться повторно, что делает её фактически кодом инициализации.
> - Поскольку этот компонент отображается только на сервере, `useTask$()` никогда не будет выполняться на клиенте.

### `track()`

Бывают случаи, когда желательно повторно запустить задачу при изменении состояния компонента. Это делается с помощью функции `track()`. Функция `track()` позволяет установить зависимость от состояния компонента на сервере, а затем повторно выполнить задачу, когда состояние изменится на клиенте.

> **Примечание**: Если всё, что вы хотите сделать, это синхронно вычислить новое состояние из существующего, то вместо этого вам следует использовать [`useComputed$()`](/docs/components/state/#usecomputed).

<CodeExample src={Track} sandboxStyle={{height: '6em'}}/>

> На сервере:
> - Функция `useTask$()` выполняется на сервере, а функция `track()` устанавливает подписку на сигнал `text`.
> - Страница отображается.
>
> На клиенте:
> - Задаче `useTask$()` не нужно выполняться (или загружаться) сразу, поскольку Qwik знает, что задача подписана на сигнал `text` от сервера.
> - Когда пользователь набирает текст в поле ввода, сигнал `text` изменяется. Qwik знает, что `useTask$()` подписана на сигнал `text`, и именно в это время замыкание `useTask$()` попадает в JavaScript VM для выполнения.
>
> Функция `useTask$()`
> - Функция `useTask$()` блокирует рендер до его завершения. Если вы не хотите блокировать рендер (как в данном случае), убедитесь, что задача решена, и запустите отложенную работу в отдельном несвязанном промисе (в нашем случае мы не ожидаем `delay()`, это приведёт к блокировке рендера).

### `track()` как функция

В приведённом выше примере `track()` использовалась для отслеживания определённого сигнала. Однако `track()` можно также использовать как функцию для отслеживания нескольких сигналов одновременно.

<CodeExample src={TrackFn} sandboxStyle={{height: '6em'}}/>

> В этом примере `track()` принимает функцию, которая не только считывает сигнал, но и преобразует его значение в верхний/нижний регистр. Функция `track()` выполняет подписку на несколько сигналов и вычисляет их значение.

### `cleanup()`

Иногда при выполнении задачи необходимо выполнить очистку. Когда запускается новая задача, вызывается функция обратного вызова `cleanup()` для предыдущей задачи (при удалении компонента из DOM также вызывается `cleanup()`).

> - Функция `cleanup()` не вызывается при завершении задачи. Она вызывается только при запуске новой задачи или при удалении компонента.
> - Функция `cleanup()` вызывается на сервере после сериализации приложений в HTML.
> - Функция `cleanup()` не переносится с сервера на клиент (очистка предназначена для освобождения ресурсов на VM, где она запущена. Она не предназначена для передачи клиенту).

В этом примере показано, как реализовать функцию демпфирования с помощью функции `cleanup()`.

<CodeExample src={Cleanup} sandboxStyle={{height: '6em'}}/>

## `useVisibleTask$()`

Иногда задача должна выполняться только на клиенте и после рендера компонента. В этом случае следует использовать `useVisibleTask$()`. Функция `useVisibleTask$()` похожа на `useTask$()`, но она выполняется только на клиенте и после первоначального рендера.

`useVisibleTask$()` имеет следующие свойства:
- работает только на клиенте;
- сразу выполняет код на клиенте, когда компонент становится видимым;
- запускается после первоначального рендера;
- не блокирует рендер.

> **Осторожно**: Использовать `useVisibleTask$()` следует в крайнем случае, поскольку он сразу выполняет код на клиенте. Qwik через [возобновляемость]() делает всё возможное, чтобы задержать выполнение кода на клиенте, а `useVisibleTask$()` - это аварийный люк, который следует использовать с осторожностью. Подробнее см. в раздел [Лучшие практики](/best-practices/#dont-register-events-eagerly-with-usevisibletask).
> Если вам нужно запустить задачу на клиенте, рассмотрите `useTask$()` с защитой выполнения на сервере.
> <CodeExample src={TrackServerGuard} sandboxStyle={{height: '6em'}}/>
> В приведённом выше примере `useTask$()` защищена флагом `isServer`. `track()` находится перед защитой, которая позволяет серверу установить подписку, но не выполняет никакого кода на сервере. Затем клиент выполняет `useTask$()`, как только сигнал `text` изменится.

В этом примере показано, как использовать `useVisibleTask$()` для инициализации часов на клиенте только тогда, когда компонент часов становится видимым.

<CodeExample src={UseVisibleTask} sandboxStyle={{height: '6em'}}/>

> Обратите внимание, что функция часов `useVisibleTask$()` не выполняется, пока компонент `<Clock>` не становится видимым. Поведение по умолчанию `useVisibleTask$()` заключается в запуске задачи, когда компонент становится видимым. Это поведение реализуется через [intersection observers](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API).

### Опция `eagerness`

Иногда желательно запускать `useVisibleTask$()` сразу, как только приложение загружается в браузер. В этом случае `useVisibleTask$()` должна выполняться в режиме стратегии `{: 'document-ready' }`.

<CodeExample src={UseVisibleTaskEager} sandboxStyle={{height: '6em'}}/>

> В этом примере часы сразу начинают идти на клиенте, независимо от того, видны они, или нет.

## `useResource$()`

TBD

### `cache()`

TBD

### `previous`

TBD
