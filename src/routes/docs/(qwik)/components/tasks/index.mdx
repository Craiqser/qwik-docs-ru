---
title: События
contributors:
  - mhevery
---
import CodeExample from '../../../../../components/code-example/index.tsx';
import UseTask from 'source:/src/routes/demo/tasks/use-task/index.tsx';
import Track from 'source:/src/routes/demo/tasks/track/index.tsx';
import TrackServerGuard from 'source:/src/routes/demo/tasks/track-server-guard/index.tsx';
import TrackFn from 'source:/src/routes/demo/tasks/track-fn/index.tsx';
import Cleanup from 'source:/src/routes/demo/tasks/cleanup/index.tsx';
import UseVisibleTask from 'source:/src/routes/demo/tasks/use-visible-task/index.tsx';
import UseVisibleTaskEager from 'source:/src/routes/demo/tasks/use-visible-task-eager/index.tsx';
import Resource from 'source:/src/routes/demo/tasks/resource/index.tsx';

# Задачи

Задачи предназначены для выполнения асинхронных операций в рамках инициализации компонента или изменения его состояния.

> **Примечание**: Задачи похожи на хук `useEffect()` в React, но различий достаточно, чтобы мы не хотели называть их одинаково, чтобы не привносить заранее сложившиеся ожидания о том, как они работают. Основными отличиями являются:
> - Задачи являются асинхронными;
> - Задача выполняется на сервере и в браузере;
> - Задачи выполняются до рендера и могут блокировать рендер.

`useTask$()` должен быть вашим стандартным API для запуска асинхронной (или синхронной) работы в рамках инициализации компонента или изменения состояния. Только когда вы не можете достичь желаемого с помощью `useTask$()`, вы должны рассмотреть возможность использования `useVisibleTask$()` или `useResource$()`.

Основным вариантом использования `useTask$()` является выполнение работы по инициализации компонента. `useTask$()` имеет такие свойства:
- Он работает на сервере и в браузере;
- Он запускается перед рендером и блокирует рендер;
- Если запущено несколько задач, то они выполняются последовательно в порядке их регистрации. Асинхронная задача будет блокировать выполнение следующей задачи до тех пор, пока она не завершится.

Задачи также можно использовать для выполнения работы при изменении состояния компонента. В этом случае задача будет выполняться заново каждый раз, когда отслеживаемое состояние изменится. Смотри главу [`track()`](#track).

Иногда задача должна выполняться только в браузере и после рендера, в этом случае следует использовать [`useVisibleTask$()`](#usevisibletask).

Иногда задача должна получать данные асинхронно и создавать сигнал (а не блокировать рендер), в этом случае следует использовать [`useResource$()`](#useresource).

## Жизненный цикл

Благодаря [возобновляемости](/docs/(qwik)/concepts/resumable/index.mdx), жизнь компонентов и их жизненный цикл распространяются на сервер и браузер. Иногда компонент будет сначала рендериться на сервере, иногда - в браузере, однако в обоих случаях жизненный цикл будет одинаковым, только его выполнение происходит в разных средах.

**В Qwik всего 3 стадии жизненного цикла:**

- `Task` - запускается перед рендером и при изменении отслеживаемого состояния;
- `Render` - запускается после `Task` и перед `VisibleTask`;
- `VisibleTask` - запускается после `Render` и когда компонент становится видимым.

```
  useTask$ ------> RENDER -----> useVisibleTask$
                            |
| --- SERVER or BROWSER --- | ----- BROWSER ----- |
                            |
                       pause|resume
```

**СЕРВЕР**: Обычно **жизнь компонента начинается на сервере** (во время SSR или SSG), в этом случае `useTask$` и `RENDER` будут выполняться на сервере, а затем в браузере запустится `VisibleTask` после того, как компонент станет видимым.

> **Заметьте**, что поскольку компонент был смонтирован на сервере, **в браузере выполняется только useVisibleTask$()**. Это происходит потому, что браузер продолжает тот же жизненный цикл, который был приостановлен на сервере после рендера и возобновлён в браузере.

**БРАУЗЕР**: Иногда компонент первоначально монтируется/рендерится в браузере, например, когда пользователь SPA переходит на новую страницу или когда "модальный" компонент первоначально появляется на странице. В этом случае жизненный цикл будет выглядеть следующим образом:

```
  useTask$ --> RENDER --> useVisibleTask$

| ---------------- BROWSER --------------- |
```

> **Заметьте**, что жизненный цикл точно такой же, но на этот раз все хуки выполняются в браузере, а не на сервере.

## `useTask$()`

- **Когда:** ДО первого рендера компонента и при изменении состояния отслеживания
- **Раз:** хотя бы раз
- **Платформа:** сервер и браузер

`useTask$()` регистрирует хук для выполнения при создании компонента, он будет запущен как минимум один раз либо на сервере, либо в браузере, в зависимости от того, где первоначально отображается компонент.

Кроме того, эта задача может быть реактивной и повторно выполняться при изменении какого-либо **отслеживаемого** [сигнала или хранилища](/docs/(qwik)/components/state/index.mdx), например, так:

```tsx
import { useTask$ } from '@builder.io/qwik';

useTask$(({ track }) => {
  track(() => store.count);
  // будет выполняться при монтировании компонента и каждый раз при изменении "store.count"
});
```

**Обратите внимание, что любое последующее выполнение всегда будет происходить в браузере**, потому что реактивность - это только для клиента.

```
  useTask$(track state) -> RENDER -> CLICK (state changes) -> RE-RUN useTask$(track state)
  ▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔            |                          ▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔
| --------- SERVER --------- | --------------- BROWSER --------------- |
                             |
                        pause|resume
```

> Если `useTask$()` не отслеживает состояние, она будет запущена **только один раз**, на сервере **или** в браузере (**но не там и там**), в зависимости от того, где первоначально отображается компонент. Эффективно использование в хуке "on mount".

`useTask$()` будет блокировать рендер компонента до тех пор, пока не разрешится его метод асинхронного обратного вызова, другими словами, задачи выполняются последовательно, даже если они асинхронны (одновременно выполняется только одна задача / задачи блокируют рендер).

Рассмотрим простейший вариант использования задачи для выполнения асинхронной работы по инициализации компонента.

<CodeExample src={UseTask} sandboxStyle={{height: '6em'}}/>

> В данном примере
> - Функция `useTask$()` вычисляет число Фибоначчи по одной записи за 100 мс. Таким образом, 40 записей занимают 4 секунды.
> - `useTask$()` выполняется на сервере как часть SSR (результат может быть кэширован в CDN).
> - Поскольку `useTask$()` блокирует рендер, рендер HTML-страницы занимает 4 секунды.
> - Поскольку у этой задачи нет `track()`, она никогда не будет выполняться повторно, что делает её фактически кодом инициализации.
> - Поскольку этот компонент отображается только на сервере, `useTask$()` никогда не будет выполняться в браузере.

> Обратите внимание, что `useTask$()` выполняется **ДО** фактического рендера и на сервере. Поэтому, если вам необходимо выполнить манипуляции с DOM, используйте вместо него [`useVisibleTask$()`](#usevisibletask), который запускается в браузере после рендера.

Используйте `useTask$()`, когда вам необходимо:

- Выполнение асинхронных задач перед рендером;
- Выполнять код только один раз перед первым рендером компонента;
- Программно выполнить код с побочными эффектами при изменении состояния.

> Обратите внимание, если вы думаете о загрузке данных (например, используя `fetch()`) внутри `useTask$`, то подумайте об использовании вместо этого [`useResource$()`](#useresource). Этот API более эффективен с точки зрения использования потоковой передачи SSR и параллельной выборки данных.

### `track()`

Бывают случаи, когда желательно повторно запустить задачу при изменении состояния компонента. Это делается с помощью функции `track()`. Функция `track()` позволяет установить зависимость от состояния компонента на сервере (если первоначальный рендер был там), а затем повторно выполнить задачу, когда состояние изменится (всегда в браузере) в браузере.

> **Примечание**: Если всё, что вы хотите сделать, это синхронно вычислить новое состояние из существующего, то вместо этого вам следует использовать [`useComputed$()`](/docs/components/state/#usecomputed).

<CodeExample src={Track} sandboxStyle={{height: '6em'}}/>

> На сервере:
> - Функция `useTask$()` выполняется на сервере, а функция `track()` устанавливает подписку на сигнал `text`.
> - Страница отображается.
>
> В браузере:
> - Задаче `useTask$()` не нужно выполняться (или загружаться) сразу, поскольку Qwik знает, что задача подписана на сигнал `text` от сервера.
> - Когда пользователь набирает текст в поле ввода, сигнал `text` изменяется. Qwik знает, что `useTask$()` подписана на сигнал `text`, и именно в это время замыкание `useTask$()` попадает в JavaScript VM для выполнения.
>
> Функция `useTask$()`
> - Функция `useTask$()` блокирует рендер до его завершения. Если вы не хотите блокировать рендер (как в данном случае), убедитесь, что задача решена, и запустите отложенную работу в отдельном несвязанном промисе (в нашем случае мы не ожидаем `delay()`, это приведёт к блокировке рендера).

> Иногда требуется запускать код только на сервере или только в браузере. Этого можно достичь, используя флаги `isServer` и `isBrowser`, экспортируемые из `@builder.io/qwik/build`, как показано выше.

### `track()` как функция

В приведённом выше примере `track()` использовалась для отслеживания определённого сигнала. Однако `track()` можно также использовать как функцию для отслеживания нескольких сигналов одновременно.

<CodeExample src={TrackFn} sandboxStyle={{height: '6em'}}/>

> В этом примере `track()` принимает функцию, которая не только считывает сигнал, но и преобразует его значение в верхний/нижний регистр. Функция `track()` выполняет подписку на несколько сигналов и вычисляет их значение.

### `cleanup()`

Иногда при выполнении задачи необходимо выполнить очистку. Когда запускается новая задача, вызывается функция обратного вызова `cleanup()` для предыдущей задачи (при удалении компонента из DOM также вызывается `cleanup()`).

> - Функция `cleanup()` не вызывается при завершении задачи. Она вызывается только при запуске новой задачи или при удалении компонента.
> - Функция `cleanup()` вызывается на сервере после сериализации приложений в HTML.
> - Функция `cleanup()` не переносится с сервера в браузер (очистка предназначена для освобождения ресурсов на VM, где она запущена. Она не предназначена для передачи клиенту).

В этом примере показано, как реализовать функцию демпфирования с помощью функции `cleanup()`.

<CodeExample src={Cleanup} sandboxStyle={{height: '6em'}}/>

## `useVisibleTask$()`

Иногда задача должна выполняться только на клиенте и после рендера компонента. В этом случае следует использовать `useVisibleTask$()`. Функция `useVisibleTask$()` похожа на `useTask$()`, но она выполняется только в браузере и после первоначального рендера. `useVisibleTask$()` регистрирует хук, который будет выполняться, когда компонент становится видимым в области просмотра, он будет запущен хотя бы один раз в браузере, и он может быть реактивным и повторно выполняться при изменении некоторого **отслеживаемого** [состояния](/docs/(qwik)/components/state/index.mdx).

`useVisibleTask$()` имеет следующие свойства:

- **Когда:** когда компонент становится видимым в браузере, и когда отслеживаемое состояние изменяется
- **Раз:** не менее одного раза
- **Платформа:** только браузер
- Работает только в браузере.
- Сразу выполняет код в браузере, когда компонент становится видимым.
- Запускается после первоначального рендера;
- Не блокирует рендер.

> **Осторожно**: Использовать `useVisibleTask$()` следует в крайнем случае, поскольку он сразу выполняет код в браузере. Qwik через [возобновляемость]() делает всё возможное, чтобы задержать выполнение кода в браузере, а `useVisibleTask$()` - это аварийный люк, который следует использовать с осторожностью. Подробнее см. в раздел [Лучшие практики](/best-practices/#dont-register-events-eagerly-with-usevisibletask).
>
> **ПРИМЕЧАНИЕ:** Не злоупотребляйте `useVisibleTask$()`, когда та же логика может быть достигнута с помощью `useTask$()` или другими средствами. Спросите себя: действительно ли этот код должен выполняться изначально в браузере? Если ответ отрицательный, то `useVisibleTask$()`, вероятно, не является правильным ответом.
>
> Как следует из названия, функция `useVisibleTask$()` полезна, когда вам нужно выполнить некоторый код, когда компонент становится видимым в области просмотра. Это полезно для:
>
> - Запуска кода ДО взаимодействия с пользователем, например, анимации или другой логики, которая должна выполняться до взаимодействия с пользователем;
> - Чтения DOM после рендера;
> - Инициализации некоторых анимаций;
> - WebGL-логики.
>
> Если вам нужно запустить задачу в браузере, рассмотрите `useTask$()` с защитой выполнения на сервере.
> <CodeExample src={TrackServerGuard} sandboxStyle={{height: '6em'}}/>
> В приведённом выше примере `useTask$()` защищена флагом `isServer`. `track()` находится перед защитой, которая позволяет серверу установить подписку, но не выполняет никакого кода на сервере. Затем браузер выполняет `useTask$()`, как только сигнал `text` изменится.

В этом примере показано, как использовать `useVisibleTask$()` для инициализации часов в браузере только тогда, когда компонент часов становится видимым.

<CodeExample src={UseVisibleTask} sandboxStyle={{height: '6em'}}/>

> Обратите внимание, что функция часов `useVisibleTask$()` не выполняется, пока компонент `<Clock>` не становится видимым. Поведение по умолчанию `useVisibleTask$()` заключается в запуске задачи, когда компонент становится видимым. Это поведение реализуется через [intersection observers](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API).

### Опция `eagerness`

Иногда желательно запускать `useVisibleTask$()` сразу, как только приложение загружается в браузер. В этом случае `useVisibleTask$()` должна выполняться в eagre-режиме. Под капотом `useVisibleTask$()` создаёт слушатель DOM, который использует [Intersection Observer](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API), чтобы определить, когда компонент становится видимым в окне просмотра. Однако эту `стратегию` можно изменить и, например, запустить код, когда `document` будет готов. Это уникальная особенность Qwik. Другие фреймворки будут выполнять этот и другой код как часть гидратации, но в Qwik вы можете указать, когда должно произойти выполнение:

- `"intersection-observer"`: (по умолчанию) когда компонент становится видимым в окне просмотра (под капотом используется [Intersection Observer](https://developer.mozilla.org/en-US/docs/Web/API/ Intersection_Observer_API));
- `"document-ready"`: когда документы заканчивают загрузку (событие "load" документа);
- `"document-idle"`: после загрузки, в первый момент простоя сайта. Под капотом используется [`requestIdleCallback()`](https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback).

<CodeExample src={UseVisibleTaskEager} sandboxStyle={{height: '6em'}}/>

> В этом примере часы в браузере сразу начинают идти, независимо от того, видны они или нет.

## `useResource$()`

`useResource$()` - это середина пути между [`useTask$()`](#usetask) и [`useComputed$()`](/docs/components/state/#usecomputed).

Сходства и различия `useResource$()` с `useTask$()`/`useComputed$()`:

- `useResource$()` не блокирует рендер в отличие от `useTask$()`;
- Возвращает значение (Signal), как и `useComputed$()`, но, в отличие от `useComputed$()`, он асинхронный;
- Это не чистая функция, как `useComputed$()`. Он может иметь побочные эффекты. В частности, предполагается, что `useResource$()` будет иметь побочные эффекты, такие как сетевые запросы;
- Он использует функции [`track()`](#track)/[`cleanup()`](#cleanup), аналогичные `useTask$()`.

<CodeExample src={Resource} sandboxStyle={{height: '6em'}}/>

### `previous`

Если `useResource$()` выполняется не первый раз, `previous` содержит предыдущее значение ресурса.

## Правила Use-хуков

При использовании хуков жизненного цикла необходимо придерживаться следующих правил:

- Они могут быть вызваны только на корневом уровне `component$` (не внутри блоков условий);
- Они могут быть вызваны только в корне другого метода `use*`, допускающего композицию.

```tsx
useHook(); // <-- ❌ не работает

export default component$(() => {
  useCustomHook(); // <-- ✅ работает
  if (condition) {
    useHook(); // <-- ❌ не работает
  }
  useTask$(() => {
    useNavigate(); // <-- ❌ не работает
  });
  const myQrl = $(() => useHook()); // <-- ❌ не работает
  return <button onClick$={() => useHook()}></button>; // <-- ❌ не работает
});

function useCustomHook() {
  useHook(); // <-- ✅ does work
  if (condition) {
    useHook(); // <-- ❌ does not work
  }
}
```
