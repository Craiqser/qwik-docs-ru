---
title: Прогрессивный
contributors:
  - adamdbradley
  - RATIU5
  - manucorporat
---

# Постепенный

Постепенно - про то, что загрузка кода происходит по мере необходимости приложения, без необходимости жадно загружать всю кодовую базу сразу.

Это связано с [основным принципом](../../think-qwik/index.mdx), который фокусируется на как можно большем откладывании **загрузки** и выполнении JavaScript. Для этого Qwik должен разбить приложение на множество лениво загружаемых фрагментов.

## Текущее состояние

[Существующие фреймворки страдают от двух проблем](https://www.builder.io/blog/dont-blame-the-developer-for-what-the-frameworks-did):

- Границы ленивой загрузки на 100% делегированы разработчику;
- Фреймворки могут лениво загружать только те компоненты, которых нет в текущем дереве рендеринга.

Проблема в том, что фреймворкам необходимо согласовывать свое внутреннее состояние с DOM. А это означает, что хотя бы один раз при гидратации приложения им необходимо выполнить полный рендер, чтобы восстановить внутреннее состояние фреймворка. После первого рендера фреймворки могут быть более хирургически точными в своих обновлениях, но ущерб уже нанесён, код загружен. Итак, у нас есть две проблемы:

- Фреймворки должны загружать и выполнять компоненты для перестройки дерева рендеринга при запуске (см. [гидратация — это дорого](https://www.builder.io/blog/hydration-is-pure-overhead)). Это вызывает жадную загрузку и выполнение всех компонентов в дереве рендеринга.
- Обработчики событий поставляются с компонентами, даже если они не нужны во время рендера. Включение обработчиков событий вызывает загрузку ненужного кода.

## Решение

Архитектура Qwik в полной мере использует современные инструменты для автоматизации задачи создания точки входа. Разработчики могут писать компоненты как обычно, в то время как оптимизатор Qwik разделит компоненты на фрагменты и загрузит их по мере необходимости.

Кроме того, среде выполнения фреймворка не нужно загружать код, который не требуется для интерактивности, даже если компонент является частью дерева рендеринга.

### Оптимизатор

Оптимизация (подробное описание [здесь](../../advanced/optimizer/index.mdx)) — это преобразование кода, которое извлекает функции в импортируемые символы верхнего уровня, что позволяет среде выполнения Qwik лениво загружать JavaScript по мере необходимости.

Оптимизатор и среда выполнения Qwik работают вместе для достижения желаемого результата фрагментарной ленивой загрузки.

Без оптимизатора либо:

- Код должен быть разбит разработчиком на импортируемые части. Было бы неестественно писать приложение, делающее плохой DX.
- Приложению пришлось бы загружать много ненужного кода, так как не было бы границ ленивой загрузки.

Среда выполнения Qwik должна понимать вывод оптимизатора. Самая большая разница для понимания заключается в том, что разбивая компонент на лениво загружаемые фрагменты, требование ленивой загрузки вводит понятие асинхронного кода. Фреймворк должен быть написан по-другому, чтобы учесть асинхронность. Существующие платформы предполагают, что весь код доступен синхронно. Это предположение предотвращает простое внедрение отложенной загрузки в существующие фреймворки (например, когда создаётся новый компонент, фреймворк предполагает, что его код инициализации может быть вызван в синхронной манере и если это первая ссылка на компонент, то его код должен быть загружен лениво, и поэтому фреймворк должен учитывать это).

### Ленивая загрузка

Ленивая загрузка является асинхронной. Qwik - это асинхронный фреймворк. Qwik понимает, что у него не всегда может быть ссылка на функцию обратного вызова, и поэтому для неё может потребоваться ленивая загрузка (в отличие от этого, большинство существующих фреймворков предполагают, что весь код доступен синхронно, что делает ленивую загрузку нетривиальной).

В Qwik всё можно загружать лениво:

- Компонент на этапе рендера (блок инициализации и блок рендеринга);
- Компонент на этапе контроля (побочные эффекты, загружается только при изменении входных данных);
- Слушатели (загружаются только при взаимодействии);
- Стили (загружаются только в том случае, если сервер ещё их не отдавал).

Ленивая загрузка - это основное свойство фреймворка, а не второстепенное.

### Оптимизатор и `$`

Давайте снова посмотрим на наш пример:

```tsx
// Суффикс `$` для `component` указывает, что компонент должен быть
// лениво загружен.
export const Counter = component$(() => {
  const store = useStore({ count: 0 });

  // Суффикс `$` для `onClick` указывает на то, что реализация для
  // обработчика должна быть загружена лениво.
  return <button onClick$={() => store.count++}>{store.count}</button>;
});
```

Обратите внимание на наличие `$` в коде. `$` — это маркер, сообщающий оптимизатору, что функция
после него должна быть загружена лениво (для подробной информации смотри [$ и правила оптимизатора](../../advanced/optimizer/index.mdx)).
`$` — это единственный символ, который напоминает оптимизатору и разработчику, что здесь происходит асинхронная отложенная загрузка.
