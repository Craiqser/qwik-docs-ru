---
title: Состояние
keywords: useState, state management, reactivity, reactive
contributors:
  - nnelgxorz
  - the-r3aper7
  - voluntadpear
  - kawamataryo
  - JaymanW
  - RATIU5
  - manucorporat
---

# Состояние

Управление состоянием - важная часть любого приложения. В Qwik мы различаем два типа состояния - реактивное и статичное.

Статичное состояние - это всё, что может быть сериализовано: строка, число, объект, массив... что угодно. Реактивное состояние, напротив, создаётся с помощью `useStore()`.

Важно отметить, что состояние в Qwik - это не состояние компонента, а скорее состояние приложения, которое может быть инстанцировано любым компонентом.

## `useSignal()`

`const signal = useSignal(initialState)` - это хук, который создает реактивный сигнал. Он принимает начальное значение и возвращает реактивный сигнал.

Реактивный сигнал, возвращаемый функцией `useSignal()`, состоит из объекта с единственным свойством `signal.value`. Если вы измените значение свойства value объекта, то любой компонент, который зависит от него, будет обновлён.

### Пример

Пример, показывающий использование `useSignal` в компоненте для отслеживания счёта.

```tsx
export default component$(() => {
  const count = useSignal(0);

  return (
    <>
      <button onClick$={() => count.value++}>Увеличить</button>
      Счёт: {count.value}
    </>
  );
});
```

В приведённом выше примере компонент App использует `useSignal()` для создания сигнала. Затем сигнал используется для отслеживания счета.

Простое обращение к свойству `count.value` приведёт к обновлению компонента при изменении значения сигнала, когда свойство будет изменено в обработчике клика.

## `useStore()`

Работает аналогично `useSignal()`, но принимает объект в качестве начального значения, думайте о хранилище как о сигнале с несколькими значениями, или как об объекте, состоящем из множества сигналов.

`const reactive = useStore(initialState)` - это хук, который создает реактивный объект. Он принимает в качестве параметра начальный объект и возвращает реактивный объект.

Реактивный объект, возвращаемый [`useStore()`](./index.mdx#usestore), похож на любой другой объект, но он реактивен: если вы измените свойство объекта, любой компонент, зависящий от него, будет обновлен.

> **ПРИМЕЧАНИЕ**
> Чтобы реактивность работала, обязательно сохраняйте ссылку на реактивный объект, а не только на его свойства. Например, написание `let { count } = useStore({ count: 0 })` и последующее изменение `count` не вызовет обновления компонентов, которые зависят от него.

### Пример

Пример, показывающий использование `useStore` в компоненте для отслеживания счёта.

```tsx
export default component$(() => {
  const state = useStore({ count: 0 });

  return (
    <>
      <button onClick$={() => state.count++}>Увеличить</button>
      Счёт: {state.count}
    </>
  );
});
```

В приведённом выше примере компонент App использует [`useStore()`](./index.mdx#usestore) для создания реактивного объекта. Затем он используется для отслеживания значения счётчика, которое отображается в компоненте.

Доступ к свойству `state.count` приведёт к обновлению компонента при изменении счётчика, когда свойство будет изменено в обработчике клика по кнопке.

### Рекурсивные значения

По умолчанию [`useStore()`](./index.mdx#usestore) отслеживает только поля верхнего уровня в вашем объекте состояния. Это означает, что для регистрации любых обновлений необходимо обновить значения полей верхнего уровня.

Например, этот код не будет работать:

```tsx
import { component$, useStore } from '@builder.io/qwik';

export default component$(() => {
  const store = useStore({
    nested: { fields: { are: 'не отслеживается' }}
  });

  return (
    <>
      <p>{store.nested.fields.are}</p>
      <button onClick$={() => (store.nested.fields.are = 'отслеживается')}>Нажми меня</button>
    </>
  );
});
```

Чтобы обновить это поле не ломая реактивность, нам придётся обновить поле верхнего уровня `nested`:

```ts
store.nested = { fields: { are: { "отслеживается" } } }
```

Для того чтобы первый пример работал, мы можем передать второй аргумент нашему методу useStore и указать ему использовать рекурсивное отслеживание всех значений в нашем хранилище, независимо от его глубины.

```tsx
export default component$(() => {
  const store = useStore(
    {
      nested: { fields: { are: 'не отслеживается' }}
    },
    { recursive: true }
  );

  return (
    <>
      <p>{store.nested.fields.are}</p>
      <button onClick$={() => (store.nested.fields.are = 'отслеживается')}>Нажми меня</button>
    </>
  );
});
```

Теперь компонент будет обновляться, как и ожидалось. Этот приём также позволяет отслеживать отдельные значения внутри массивов!

```tsx
import { component$, useStore } from '@builder.io/qwik';

export default component$(() => {
  const store = useStore(
    {
      letters: ['A', 'B', 'C']
    },
    { recursive: true }
  );

  return (
    <>
      {store.letters.map((letter) => (
        <p>{letter}</p>
      ))}
      <button
        onClick$={() => {
          store.letters[2] = 'Z';
        }}
      >
        Нажми меня
      </button>
    </>
  );
});
```

## Передача состояния другим компонентам

Одной из приятных особенностей Qwik является то, что состояние может быть передано другим компонентам, и они могут читать и записывать его, позволяя данным течь по дереву компонентов в обоих направлениях.

Существует несколько способов передачи состояния другим компонентам.

### Использование параметров

Самый простой способ передачи состояния другим компонентам - это передача его в виде параметров. Так вы обычно делаете в React, и это также работает в Qwik.

```tsx
export const Parent = component$(() => {
  const userData = useStore({
    count: 0,
  });

  return (
    <>
      <Child userData={userData} />
    </>
  );
});

export const Child = component$(({ userData }) => {
  return (
    <>
      <button onClick$={() => userData.count++}>Increment</button>
      Count: {userData.count}
    </>
  );
});
```

### Использование API контекста

API контекста - это способ передачи состояния компонентам без необходимости передавать его через параметры. Все дочерние компоненты в дереве автоматически получают ссылку на состояние с доступом на чтение/запись.

Подробнее об этом можно прочитать в разделе [Контекст](./../context/index.mdx).

```tsx
const CTX = createContext('stuff');

export const Stores = component$(() => {
  const userData = useStore({
    count: 0,
  });

  useContextProvider(CTX, userData);

  return (
    <>
      <Child />
    </>
  );
});

export const Child = component$(() => {
  const userData = useContext(CTX);
  return (
    <>
      <button onClick$={() => userData.count++}>Increment</button>
      Count: {userData.count}
    </>
  );
});
```

## Вычисляемые свойства

Вычисляемые свойства - это значения, которые получены из других значений. Они полезны, когда вам требуется значение, которое является производным от других, и вы хотите, чтобы оно с ними синхронизировалось.

В Qwik есть два способа создания вычисляемых свойств: с помощью [`useWatch$()`](./../lifecycle/index.mdx#usewatch) или [`useResource$()`](./../resource/index.mdx).

Основное различие между ними заключается в том, что [`useWatch$()`](./../lifecycle/index.mdx#usewatch) допускает побочные эффекты и выполнение сериализуется, а [`useResource$()`](./../resource/index.mdx) является асинхронным и несколько вызовов useResource могут происходить параллельно.

`useWatch$()` обычно используется для вычисления промежуточного состояния, в то время как [`useResource$()`](./../resource/index.mdx) имеет лучшую эргономику для вычисления конечного состояния, используемого для рендеринга. Рассмотрим несколько примеров.

### Пример использования [`useWatch$()`](./../lifecycle/index.mdx#usewatch)

```tsx
export default component$(() => {
  const state = useStore({
    count: 0,
    doubleCount: 0
  });

  useWatch$(({ track }) => {
    track(() => state.count);
    state.doubleCount = state.count * 2;
  });

  return (
    <>
      <button onClick$={() => state.count++}>Увеличить</button>
      Счёт: {state.count}
      Счёт * 2: {state.doubleCount}
    </>
  );
});
```

### Пример использования [`useResource$()`](./../resource/index.mdx)

```tsx
export default component$(() => {
  const state = useStore({
    count: 0,
  });

  const doubleCount = useResource$(({ track }) => {
    track(() => state.count);
    return state.count * 2;
  });

  return (
    <>
      <button onClick$={() => state.count++}>Увеличить</button>
      Счёт: {state.count}
      Счёт * 2: {doubleCount.promise}
    </>
  );
});
```

Как [useWatch](./../lifecycle/index.mdx#usewatch), так и [useResource](./../resource/index.mdx) подробно описаны в соответствующих разделах.

## Реактивность

Благодаря фрагментарной реактивности Qwik, обновляться будут только те компоненты, которые зависят от состояния. Это огромный выигрыш в производительности, так как обновляются только те компоненты, которые действительно необходимо обновить.

## `noSerialize()`

Иногда вы можете захотеть сохранить значение в состоянии, но не хотите, чтобы оно было сериализовано. Это полезно для хранения значений, которые не являются сериализуемыми, например, функций или классов.

```tsx
import { component$, useStore, noSerialize } from '@builder.io/qwik';

export const App = component$(() => {
  const state = useStore({
    monacoInstance: null
  });

  useClientEffect$(() => {
    // Monaco не является сериализуемым, поэтому мы не можем хранить его в состоянии, не используя `noSerialize()`.
    state.monacoInstance = noSerialize(new Monaco());
  });
  return <></>;
});
```
