---
contributors:
  - nnelgxorz
  - the-r3aper7
  - voluntadpear
  - kawamataryo
  - JaymanW
  - RATIU5
  - manucorporat
---

# Состояние

Управление состоянием - важная часть любого приложения. В Qwik мы различаем два типа состояния - реактивное и статическое.

Статичное состояние - это всё, что может быть сериализовано: строка, число, объект, массив... что угодно. Реактивное состояние, напротив, создаётся с помощью `useStore()`.

Важно отметить, что состояние в Qwik - это не состояние компонента, а скорее состояние приложения, которое может быть инстанцировано любым компонентом.

## `useStore()`

`const reactive = useStore(initialState)` - это хук, который создает реактивный объект. Он принимает в качестве параметра начальное состояние и возвращает реактивный объект.

Реактивный объект, возвращаемый `useStore()`, похож на любой другой объект, но он реактивен: если вы измените свойство объекта, любой компонент, зависящий от него, будет обновлен.

> **ПРИМЕЧАНИЕ**
> Чтобы реактивность работала, обязательно сохраняйте ссылку на реактивный объект, а не только на его свойства. Например, написание `let { count } = useStore({ count: 0 })` и последующее изменение `count` не вызовет обновления компонентов, которые зависят от него.

### Пример

Пример, показывающий, как `useStore` используется в примере Counter для отслеживания значения счётчика.

```tsx
export const App = component$(() => {
  const state = useStore({ count: 0 });

  return (
    <>
      <button onClick$={() => state.count++}>Increment</button>
      Count: {state.count}
    </>
  );
});
```

В приведённом выше примере компонент App использует `useStore()` для создания реактивного объекта. Затем он используется для отслеживания значения счётчика, которое отображается в компоненте.

Доступ к свойству `state.count` приведёт к обновлению компонента при изменении счётчика, когда свойство будет изменено в обработчике клика по кнопке.

### Рекурсивные значения

По умолчанию `useStore()` отслеживает только поля верхнего уровня в вашем объекте состояния. Это означает, что для регистрации любых обновлений необходимо обновить значения полей верхнего уровня.

Например, этот код не будет работать:

```tsx
import { component$, useStore } from '@builder.io/qwik';

export const App = component$(() => {
  const store = useStore({
    nested: { fields: { are: "not tracked" }}
  })

  return (
    <>
      <p>{store.nested.fields.are}</p>
      <button onClick$={() => store.nested.fields.are = "tracked"}>Click me</button>
    </>
  );
});
```

Чтобы обновить это поле не ломая реактивность, нам придётся обновить поле верхнего уровня `nested`:

```ts
store.nested = { fields: { are: { "tracked" } } }
```

Для того чтобы первый пример работал, мы можем передать второй аргумент нашему методу useStore и указать ему использовать рекурсивное отслеживание всех значений в нашем хранилище, независимо от его глубины.

```tsx
export const App = component$(() => {
  const store = useStore({
    nested: { fields: { are: "not tracked" }}
  }, { recursive: true })

  return (
    <>
      <p>{store.nested.fields.are}</p>
      <button onClick$={() => store.nested.fields.are = "tracked"}>Click me</button>
    </>
  );
});
```

Теперь компонент будет обновляться, как и ожидалось. Этот приём также позволяет отслеживать отдельные значения внутри массивов!

```tsx
import { component$, useStore } from '@builder.io/qwik';

export const App = component$(() => {
  const store = useStore({
    letters: ["A", "B", "C"]
  }, { recursive: true })

  return (
    <>
      {store.letters.map(letter => <p>{letter}</p>)}
      <button onClick$={() => { store.letters[2] = "Z"}}>Click me</button>
    </>
  );
});
```

## Передача состояния другим компонентам

Одной из приятных особенностей Qwik является то, что состояние может быть передано другим компонентам, и они могут читать и записывать его, позволяя данным течь по дереву компонентов в обоих направлениях.

Существует несколько способов передачи состояния другим компонентам.

### Использование параметров

Самый простой способ передачи состояния другим компонентам - это передача его в виде параметров. Так вы обычно делаете в React, и это также работает в Qwik.

```tsx
export const Parent = component$(() => {
  const userData = useStore({
    count: 0,
  });

  return (
    <>
      <Child userData={userData} />
    </>
  );
});

export const Child = component$(({ userData }) => {
  return (
    <>
      <button onClick$={() => userData.count++}>Increment</button>
      Count: {userData.count}
    </>
  );
});
```

### Использование API контекста

API контекста - это способ передачи состояния компонентам без необходимости передавать его через параметры. Все дочерние компоненты в дереве автоматически получают ссылку на состояние с доступом на чтение/запись.

Подробнее об этом можно прочитать в разделе [Контекст](./../context/index.mdx).

```tsx
const CTX = createContext('stuff');

export const Stores = component$(() => {
  const userData = useStore({
    count: 0,
  });

  useContextProvider(CTX, userData);

  return (
    <>
      <Child />
    </>
  );
});

export const Child = component$(() => {
  const userData = useContext(CTX);
  return (
    <>
      <button onClick$={() => userData.count++}>Increment</button>
      Count: {userData.count}
    </>
  );
});
```

## Вычисляемые свойства

Вычисляемые свойства - это значения, которые получены из других значений. Они полезны, когда вам требуется значение, которое является производным от других, и вы хотите, чтобы оно с ними синхронизировалось.

В Qwik есть два способа создания вычисляемых свойств: с помощью `useWatch$()` или `useResource$()`.

Основное различие между `useWatch$()` и `useResource$()` заключается в том, что `useWatch$()` допускает побочные эффекты и его выполнение синхронно, в то время как `useResource$()` является асинхронным, и несколько вызовов `useResource` могут выполняться параллельно.

`useWatch$()` обычно используется для вычисления промежуточного состояния, в то время как `useResource$()` имеет лучшую эргономику для вычисления конечного состояния, используемого для рендеринга. Рассмотрим несколько примеров.

### Пример `useWatch$()`

```tsx
export const App = component$(() => {
  const state = useStore({
    count: 0,
    doubleCount: 0
  });

  useWatch$(({ track }) => {
    track(() => state.count);
    state.doubleCount = state.count * 2;
  });

  return (
    <>
      <button onClick$={() => state.count++}>Increment</button>
      Count: {state.count}
      Count * 2: {state.doubleCount}
    </>
  );
});
```

### Пример `useResource$()`

```tsx
export const App = component$(() => {
  const state = useStore({
    count: 0,
  });

  const doubleCount = useResource$(({ track }) => {
    track(() => state.count);
    return state.count * 2;
  });

  return (
    <>
      <button onClick$={() => state.count++}>Increment</button>
      Count: {state.count}
      Count * 2: {doubleCount.promise}
    </>
  );
});
```

Как [useWatch](./../lifecycle/index.mdx#usewatch), так и [useResource](./../resource/index.mdx) подробно описаны в соответствующих разделах.

## Реактивность

Благодаря фрагментарной реактивности Qwik, обновляться будут только те компоненты, которые зависят от состояния. Это огромный выигрыш в производительности, так как обновляются только те компоненты, которые действительно необходимо обновить.
