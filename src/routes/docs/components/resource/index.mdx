---
title: Ресурсы
contributors:
  - nnelgxorz
  - irfanullahjan
  - RATIU5
  - manucorporat
---

# useResource$()

Этот метод позволяет асинхронно создавать вычисляемые значения. Асинхронная функция, переданная в качестве первого параметра, будет вызываться при монтировании компонента и изменении отслеживаемых значений.

Как и все `use`-методы использования, он должен вызываться в контексте `component$()`, с соблюдением всех [правил хука](./../lifecycle/index.mdx#правила).

```tsx
const store = useStore({
  bar: 'foo'
})
const resource = useResource$(async (ctx) => {
  ctx.track(() => store.bar); // Ресурс будет генерировать значение при изменении store.bar.
  ctx.track(() => props.url); // track() можно вызывать несколько раз, чтобы отслеживать несколько значений.
  ctx.cleanup(() => {
    // В случае, если ресурс необходимо очистить, будет вызвана эта функция.
    // Позволяет очищать такие ресурсы, как таймеры, подписки, запросы на выборку и т.д.
  });

  // cleanup() также может вызываться несколько раз.
  ctx.cleanup(() => console.log('cleanup'));

  // Ресурсы могут содержать асинхронные вычисления.
  const value = await expensiveCompute(store.bar, props.url);
  return value;
});
```

Как мы видим в приведённом выше примере, `useResouce$()` возвращает объект `ResourceReturn<T>`, который работает как полностью реактивный промис, содержащий данные и состояние ресурса.

Состоянием `resource.state` может быть одна из следующих строк:

- `pending` - данные еще не доступны;
- `resolved` - данные доступны;
- `rejected` - данные недоступны из-за ошибки или тайм-аута.

Функция обратного вызова, переданная в `useResource$()`, запускается сразу после завершения обратных вызовов `useMount$()` и `useWatch$()`. Дополнительные сведения смотри в разделе [Жизненный цикл](./../lifecycle).

## `<Resource>`

`<Ресурс>` - это компонент, который рендерит свои дочерние элементы, когда промис разрешён, и отображает элементы отката, когда ресурс ожидает разрешения или отклонён.

```tsx
  <Resource
    value={weatherResource}
    onPending={() => <div>Загрузка...</div>}
    onRejected={() => <div>Не удалось загрузить данные о погоде</div>}
    onResolved={(weather) => {
      return <div>Температура: {weather.temp}</div>;
    }}
  />
```

Обратите внимание, что `<Resource>` не обязан использовать `useResource$()`. Это просто удобный способ отобразить состояние ресурса.

### Пример использования `useResource$()` с `<Resource>`

Пример, показывающий, как с помощью `useResource` выполнить вызов `fetch` для запроса данных погоды при каждом изменении входного параметра - названия города.

```tsx
export const Cmp = component$(() => {
  const store = useStore({
    city: '',
  });

  const weatherResource = useResource$<any>(async ({ track, cleanup }) => {
    const cityName = track(() => store.city);
    const abortController = new AbortController();
    cleanup(() => abortController.abort('cleanup'));
    const res = await fetch(`http://weatherdata.com?city=${cityName}`, {
      signal: abortController.signal,
    });
    const data = res.json();
    return data;
  });

  return (
    <div>
      <input name="city" onInput$={(ev: any) => (store.city = ev.target.value)} />
      <Resource
        value={weatherResource}
        onPending={() => <div>Загрузка...</div>}
        onResolved={(weather) => {
          return <div>Температура: {weather.temp}</div>;
        }}
      />
    </div>
  );
});
```

### Пример без `<Resource>`

```tsx
export const Cmp = component$(() => {
  const store = useStore({
    city: '',
  });

  const weatherResource = useResource$<any>(async ({ track, cleanup }) => {
    const cityName = track(() => store.city);
    const abortController = new AbortController();
    cleanup(() => abortController.abort('cleanup'));
    const res = await fetch(`http://weatherdata.com?city=${cityName}`, {
      signal: abortController.signal,
    });
    const data = res.json();
    return data;
  });

  return (
    <div>
      <input name="city" onInput$={(ev: any) => (store.city = ev.target.value)} />
      {weatherResource.state === 'pending' && (
        <div>Загрузка...</div>
      )}
      {weatherResource.state === 'resolved' && (
        <div>Температура: {weatherResource.resolved.temp}</div>
      )}
    </div>
  );
});
```

> **ПРИМЕЧАНИЕ**
> Мы настоятельно рекомендуем использовать `<Resource/>` всегда, когда это возможно, так как этот компонент более эффективно избегает ререндеров и лучше оптимизирован для SSR.
