---
title: Слоты
keywords: children, transclusion, content projection, parent
contributors:
  - RATIU5
  - manucorporat
  - forresst
  - adamdbradley
---

# Слоты

Слоты позволяют компоненту рассматривать дочерние JSX-элементы компонента как форму ввода и отображать эти элементы в DOM-дереве компонента.

Эта концепция имеет разные названия в различных фреймворках:

- В Angular это называется Content Projection;
- В React это `children` параметров;
- В Vue и веб-компонентах это тоже называется слотами.

Слоты в Qwik являются символическими, что позволяет Qwik рендерить родительские и дочерние компоненты в полной изоляции друг от друга, позволяя отображать родительский компонент без повторного рендера дочерних и наоборот.

> Примечание: Поскольку слоты являются символическими, дочерние элементы НЕ могут быть прочитаны или преобразованы компонентами, как это возможно в React.

## Использование

Основным API для достижения этой цели является компонент `<Slot>`, экспортируемый в `@builder.io/qwik`:

```tsx
import { Slot } from '@builder.io/qwik';

export const Button = component$(() => {
  return (
    <button>
      <Slot />
    </button>
  );
});
```

Компонент `<Slot>` является заполнителем для дочерних элементов компонента. Компонент `<Slot>` будет заменён дочерними элементами этого компонента при рендере приложения.

Давайте посмотрим, как используется этот компонент:

```tsx
<Button>
  {... это будет размещено там, где используется <Slot> внутри компонента Button ...}
</Button>
```

### Именованные слоты

Компонент `Slot` может использоваться несколько раз в одном и том же компоненте, если он имеет другое свойство `name`:

```tsx
import { Slot } from '@builder.io/qwik';

export const Button = component$(() => {
  return (
    <button>
      <div>
        <Slot name="start" /> {/* "start" slot */}
      </div>
      <Slot /> {/* default slot */}
      <div>
        <Slot name="end" /> {/* "end" slot */}
      </div>
    </button>
  );
});
```

Теперь, при использовании компонента `<Button>`, мы можем передавать дочерние элементы и указывать, в какой слот они должны быть помещены, используя атрибут `q:slot`:

```tsx
<Button>
  <div q:slot="start">Start</div>
  <div>Default</div>
  <div q:slot="end">End</div>
  <icon q:slot="end"></icon>
</Button>
```

Результат:

```html
<button>
  <div>
    <!-- Slot name=start -->
    <div q:slot="start">Start</div>
  </div>
  <!-- Slot (default) -->
  <div>Default</div>
  <div>
    <!-- Slot name=end -->
    <div q:slot="end">End</div>
    <icon q:slot="end"></icon>
  </div>
</button>
```

Помните что:

- Если `q:slot` не указан или это пустая строка, содержимое будет проецироваться в `<Slot>` по умолчанию, т.е. `<Slot>` без свойства `name`.
- Несколько атрибутов `q:slot ="end"` объединяют элементы вместе в отображении содержимого.

### Неотображаемое содержимое

Qwik хранит весь контент, даже если он не отображается. Это потому, что контент может быть отображён позднее.

```tsx
export const Project = component$(() => {
  // Обратите внимание, у этого компонента нет компонента <Slot>
  return <div />;
});

export const MyApp = component$(() => {
  return <Project>текст без обёртки</Project>;
});
```

Результат:

```html
<my-app>
  <q:template q:slot="">текст без обёртки</q:template>
  <div></div>
</my-app>
```

Обратите внимание, что неотображаемое содержимое перемещено в инертный `<q:template>`. Это делается на тот случай, если компонент `Project` перерендерится и вставит `<Slot>`. В этом случае мы не хотим повторно отображать родительский компонент только для создания проецируемого содержимого. Благодаря сохранению неотображаемого содержимого при первоначальном рендере родителя, рендер двух компонентов может оставаться независимым.

### Некорректное отображение

Атрибут `q:slot` должен быть прямым потомком компонента.

```tsx
export const Project = component$(() => { ... })

export const MyApp = component$(() => {
  return (
    <Project>
      <span q:slot="title">Хорошо, прямой наследник.</span>
      <div>
        <span q:slot="title">Ошибка, не является прямым наследником.</span>
      </div>
    </Project>
  );
});
```

### Отображение vs `наследник`

Все фреймворки нуждаются в том, чтобы компонент мог обернуть своё сложное содержимое условным образом. Эта проблема решается по-разному, но есть два преобладающих подхода:

- `отображение` - это декларативный способ описания того, как содержимое попадает из родительского шаблона в место отображения.

- `наследник` - относится к подходам vDOM, которые обрабатывают содержимое точно так же, как и другой вход.

Эти два подхода лучше всего можно описать как декларативный и императивный. Они оба имеют свой набор преимуществ и недостатков.

Qwik использует декларативный подход отображения. Причина этого в том, что Qwik должен иметь возможность отображать родительские/дочерние компоненты независимо друг от друга. При императивном (`наследник`) подходе дочерний компонент может изменять потомков бесчисленным количеством способов. Если бы дочерний компонент зависел от `наследник`а, он был бы вынужден повторно вызывать функцию рендера каждый раз, когда родительский компонент повторно применял бы изменения для императивного преобразования к `наследник`у. Дополнительный рендер явно противоречит целям изолированного рендеринга компонентов Qwik.

Например, давайте вернёмся к нашему примеру выше с компонентом `Collapsible`:

- Родитель должен иметь возможность изменить заголовок и текст, не заставляя компонент `Collapsible` выполнять ререндер. Qwik должен иметь возможность распространить изменения в шаблоне `MyApp`, не затрагивая компонент `Collapsible`.
- Дочерний компонент должен изменить то, что отображается, без повторного рендера родительского компонента. В нашем случае `Collapsible` должен иметь возможность показывать/скрывать слот `q:slot` по умолчанию без загрузки и повторного рендера компонента `MyApp`.

Чтобы два компонента имели независимый жизненный цикл, отображение должно быть декларативным. Таким образом, либо родитель, либо потомок могут изменить то, что отображается, или то, как это отображается, без повторного рендера другого компонента.

С императивным подходом компонент может принудительно изменять дочерние элементы бесконечным числом способов. Это чрезвычайно затруднило бы создание фреймворка, который не заставлял бы повторно рендерить как родительский, так и дочерний элементы.

## Расширенный пример

Пример сворачиваемого компонента, который проецирует своё содержимое по условию.

```tsx
export const Collapsible = component$(() => {
  const isOpen = useSignal(true);

  return (
    <div class="collapsible">
      <div class="title" onClick$={() => (isOpen.value = !isOpen.value)}>
        <Slot name="title"></Slot>
      </div>
      {isOpen.value ? <Slot /> : null}
    </div>
  );
});
```

Вышеупомянутый компонент можно использовать из родительского компонента следующим образом:

```tsx
export const MyApp = component$(() => {
  return (
    <Collapsible>
      <span q:slot="title">Текст заголовка</span>
      Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus vulputate accumsan pretium.
    </Collapsible>
  );
});
```

Компонент `Collapsible` всегда будет отображать заголовок, но основной текст будет отображаться только в том случае, если `store.isOpen` имеет значение `true`.

### Вывод рендера

Приведённый выше пример в HTML будет выглядеть так, если `isOpen === true`:

```html
<my-app>
  <div class="collapsible">
    <div class="title">
      <span q:slot="title" has-content>Текст заголовка</span>
    </div>
    Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus vulputate accumsan pretium.
  </div>
</my-app>
```
