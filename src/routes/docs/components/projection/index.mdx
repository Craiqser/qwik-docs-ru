---
title: Отображение
contributors:
  - RATIU5
  - manucorporat
  - forresst
  - adamdbradley
---

# Отображение содержимого

Отображение содержимого позволяет компоненту рассматривать дочерние элементы JSX компонента как форму ввода и отображать дочерние элементы в JSX компонента.

Пример сворачиваемого компонента, который отображает своё содержимое по условию.

```tsx
export const Collapsible = component$(() => {
  const store = useStore({ isOpen: true });

  return (
    <div class="collapsible">
      <div class="title" onClick$={() => (store.isOpen = !store.isOpen)}>
        <Slot name="title"></Slot>
      </div>
      {store.isOpen ? <Slot /> : null}
    </div>
  );
});
```

Вышеупомянутый компонент можно использовать из родительского компонента следующим образом:

```tsx
export const MyApp = component$(() => {
  return (
    <Collapsible>
      <span q:slot="title">Текст заголовка</span>
      Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus vulputate accumsan pretium.
    </Collapsible>
  );
});
```

Компонент `Collapsible` всегда будет отображать заголовок, но основной текст будет отображаться только в том случае, если `store.isOpen` имеет значение `true`.

## Вывод рендерера

Приведённый выше пример рендерится в следующий HTML, если `isOpen === true`:

```html
<my-app>
  <collapsible>
    <q:slot q:key="title" has-content>
      <span q:slot="title" has-content>Текст заголовка</span>
    </q:slot>
    <q:slot>
      Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus vulputate accumsan pretium.
    </q:slot>
  </collapsible>
</my-app>
```

## Слоты

Qwik использует слоты как способ включения содержимого родительского компонента к дочернему содержимому.

Родительский компонент использует атрибут `q:slot` для определения источника содержимого и элемент `<Slot>` для определения места назначения содержимого. Предполагается, что безымянный (или развернутый) контент имеет атрибут `q:slot=""`.

```tsx
export const Project = component$(() => {
  return (
    <div>
      <Slot />
    </div>
  );
});

export const MyApp = component$(() => {
  return (
    <Project>
      внешний текст
      <span>внутренний текст без q:slot</span>
      <span q:slot="">внутренний текст с q:slot с именем по умолчанию</span>
    </Project>
  );
});
```

Результат рендера:

```html
<my-app>
  <project>
    <div>
      <q:slot q:key has-content>
        внешний текст
        <span>внутренний текст без q:slot</span>
        <span q:slot="">внутренний текст с q:slot с именем по умолчанию</span>
      </q:slot>
    </div>
  </project>
</my-app>
```

### Именованные слоты

Используйте атрибуты `q:slot` для именования слотов.

```tsx
export const Project = component$(() => {
  return (
    <div>
      <div class="title">
        <Slot name="title" />
      </div>
      <Slot />
    </div>
  );
});

export const MyApp = component$(() => {
  return (
    <Project>
      внешний текст
      <span q:slot="title">первый заголовок</span>
      <span>внутренний текст без q:slot</span>
      <span q:slot="title">второй заголовок</span>
    </Project>
  );
});
```

Результат:

```html
<my-app>
  <project>
    <div>
      <div class="title">
        <span q:slot="title">первый заголовок</span>
        <span q:slot="title">второй заголовок</span>
      </div>
      <q:slot q:key="" has-content>
        внешний текст
        <span>внутренний текст без q:slot</span>
      </q:slot>
    </div>
  </project>
</my-app>
```

Помните что:

- Атрибут `name=""` ведёт себя так же, как отсутствие атрибута или элемента-обертки.
- Несколько атрибутов `q:slot="title"` объединяют элементы в отображении контента.

### Не отображаемое содержимое

Qwik хранит весь контент, даже если он не отображается. Это потому, что контент может быть отображён позднее.

```tsx
export const Project = component$(() => {
  return <div />;
});

export const MyApp = component$(() => {
  return <Project>текст без обёртки</Project>;
});
```

Результат:

```html
<my-app>
  <project>
    <q:template q:slot="">текст без обёртки</q:template>
    <div></div>
  </project>
</my-app>
```

Обратите внимание, что неотображаемое содержимое перемещено в инертный `<q:template>`. Это делается на тот случай, если компонент `Project` перерендерится и вставит `<Slot>`. В этом случае мы не хотим повторно отображать родительский компонент только для создания проецируемого содержимого. Благодаря сохранению неотображаемого содержимого при первоначальном рендере родителя, рендер двух компонентов может оставаться независимым.

### Содержание слота по умолчанию

Можно вставить содержимое слота по умолчанию, если родительский компонент не предоставляет значения.

```tsx
export const Project = component$(() => {
  return (
    <>
      <Slot name="title">заголовок по умолчанию</Slot>
      <Slot>содержимое по умолчанию</Slot>
    </>
  );
});

export const MyApp = component$(() => {
  return <Project>Переданное содержимое</Project>;
});
```

Результат:

```html
<my-app>
  <project>
    <q:slot q:key="title">
      <q:slot-default>заголовок по умолчанию</q:slot-default>
    </q:slot>
    <q:slot has-content>
      <q:slot-default>содержимое по умолчанию</q:slot-default>
      Переданное содержимое
    </q:slot>
  </project>
</my-app>
```

Обратите внимание, что содержимое по умолчанию может быть включено в `<Slot>default content</Slot>`. Этот контент всегда будет вставляться в результирующий вывод HTML, заключенный в `<q:slot-default/>`. Видимость `<q:slot-default/>` контролируется атрибутом `has-content`. Подробнее в следующем разделе `CSS`.

## CSS

Для того чтобы Qwik мог самостоятельно отрисовывать компоненты, он должен уметь считывать правила отображения из HTML. Это достигается с помощью элемента `<q:slot>`, элемента `<q:slot-default/>` и атрибута `q:slot`. Чтобы сделать эти элементы инертными, Qwik добавляет в тег `<style>` следующий код CSS:

```html
<style>
  q:slot,q:slot-default {
    /** This marks the extra elements inert for flex, etc... **/
    display: contents;
  }
  q:slot.has-content > q:slot-default {
    /** Suppress the default value of Slot if parent provided content **/
    display: none:
  }
</style>
```

## Ошибка отображения

Атрибут `q:slot` должен быть прямым потомком компонента.

```tsx
export const Project = component$(() => { ... })

export const MyApp = component$(() => {
  return (
    <Project>
      <span q:slot="title">Хорошо, прямой наследник.</span>
      <div>
        <span q:slot="title">Ошибка, не является прямым наследником.</span>
      </div>
    </Project>
  );
});
```

## Отображение vs `наследник`

Все фреймворки нуждаются в том, чтобы компонент мог обернуть своё сложное содержимое условным образом. Эта проблема решается по-разному, но есть два преобладающих подхода:

- `отображение` - это декларативный способ описания того, как содержимое попадает из родительского шаблона в место отображения.

- `наследник` - относится к подходам vDOM, которые обрабатывают содержимое точно так же, как и другой вход.

Эти два подхода лучше всего можно описать как декларативный и императивный. Они оба имеют свой набор преимуществ и недостатков.

Qwik использует декларативный подход отображения. Причина этого в том, что Qwik должен иметь возможность отображать родительские/дочерние компоненты независимо друг от друга. При императивном (`наследник`) подходе дочерний компонент может изменять потомков бесчисленным количеством способов. Если бы дочерний компонент зависел от `наследник`а, он был бы вынужден повторно вызывать функцию рендера каждый раз, когда родительский компонент повторно применял бы изменения для императивного преобразования к `наследник`у. Дополнительный рендер явно противоречит целям изолированного рендеринга компонентов Qwik.

Например, давайте вернёмся к нашему примеру выше с компонентом `Collapsible`:

- Родитель должен иметь возможность изменить заголовок и текст, не заставляя компонент `Collapsible` выполнять ререндер. Qwik должен иметь возможность распространить изменения в шаблоне `MyApp`, не затрагивая компонент `Collapsible`.
- Дочерний компонент должен изменить то, что отображается, без повторного рендера родительского компонента. В нашем случае `Collapsible` должен иметь возможность показывать/скрывать слот `q:slot` по умолчанию без загрузки и повторного рендера компонента `MyApp`.

Чтобы два компонента имели независимый жизненный цикл, отображение должно быть декларативным. Таким образом, либо родитель, либо потомок могут изменить то, что отображается, или то, как это отображается, без повторного рендера другого компонента.

С императивным подходом компонент может принудительно изменять дочерние элементы бесконечным числом способов. Это чрезвычайно затруднило бы создание фреймворка, который не заставлял бы повторно рендерить как родительский, так и дочерний элементы.
