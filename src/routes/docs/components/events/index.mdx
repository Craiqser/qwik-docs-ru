---
title: События
contributors:
  - voluntadpear
  - the-r3aper7
  - RATIU5
  - manucorporat
  - nnelgxorz
  - adamdbradley
---

# События

Для того чтобы веб-приложение было интерактивным, оно нуждается в реагировании на пользовательские события. Это делается путем регистрации функций обратного вызова в шаблоне JSX.

```tsx
export const Counter = component$(() => {
  const store = useStore({ count: 0 });

  return <button onClick$={() => store.count++}>{store.count}</button>;
});
```

В приведённом выше примере атрибут `onClick$` элемента `<button>` используется, чтобы сообщить Qwik, что функция обратного вызова `() => store.count++` должна выполняться каждый раз, когда на `<button>` происходит событие `click`.

Обратите внимание, что `onClick$` заканчивается на `$`. Это подсказка как оптимизатору Qwik, так и разработчику о том, что в этом месте происходит специальное преобразование. Наличие суффикса `$` подразумевает здесь границу с ленивой загрузкой. Код, связанный с обработчиком `click`, не будет загружаться до тех пор, пока пользователь не запустит событие. Более подробную информацию смотри в разделе [Правила оптимизатора](./../../advanced/optimizer/index.mdx).

В приведённом выше примере слушатель события `click` тривиален в реализации. Но в реальных приложениях слушатель может обращаться к сложному коду. Создавая границу ленивой загрузки, Qwik может выделить весь код, расположенный в обработчике, в отдельный фрагмент, и отложить его загрузку до тех пор, пока пользователь не нажмёт на кнопку.

Вы также можете передавать QRL-выражения в качестве значений для слушателей событий. Например, приведённый выше пример можно записать следующим образом:

```tsx
import { component$, useStore, $ } from "@builder.io/qwik";

export const Counter = component$(() => {
  const store = useStore({ count: 0 });
  const incrementCount = $(() => store.count++)

  return <button onClick$={incrementCount}>{store.count}</button>;
});
```

## Prevent default

Из-за асинхронной природы Qwik выполнение обработчика события может быть отложено, поскольку реализация еще не загружена. Это создает проблему, когда обработчику события необходимо предотвратить поведение события по умолчанию. Традиционный `event.preventDefault()` не будет работать, поэтому вместо этого используйте атрибут Qwik `preventdefault:{eventName}`:

```tsx
export const PreventDefaultExample = component$(() => {
  return (
    <a
      href="/about"
      preventdefault:click // Это предотвратит поведение по умолчанию события "click".
      onClick$={(event) => {
        // PreventDefault здесь не сработает, так как хэндл отправляется асинхронно.
        // event.preventDefault();
        singlePageNavigate('/about');
      }}
    >
      Перейти на страницу с информацией
    </a>
  );
});
```

## События объектов window и document

До сих пор мы обсуждали, как прослушивать события, идущие от элементов разметки. Есть события (например, `scroll` и `mousemove`), которые требуют прослушивания на объекте `window` или `document`. По этой причине Qwik позволяет использовать префиксы `document:on` и `window:on`.

```tsx
export const EventExample = component$(() => {
  const store = useStore({
    scroll: 0,
    mouse: { x: 0, y: 0 },
    clickCount: 0,
  });

  return (
    <button
      window:onScroll$={(e) => (store.scroll = window.scrollY)}
      document:onMouseMove$={(e) => {
        store.mouse.x = e.x;
        store.mouse.y = e.y;
      }}
      onClick$={() => store.clickCount++}
    >
      scroll: {store.scroll}
      mouseMove: {store.mouse.x}, {store.mouse.y}
      click: {store.clickCount}
    </button>
  );
});
```

Назначение `window:on`/`document:on` - зарегистрировать событие компонента в текущем местоположении DOM, но заставить его получать события от `window`/`document`. В этом есть два преимущества:

1. События могут быть зарегистрированы декларативно в вашем JSX;
2. События автоматически очищаются при уничтожении компонента (не требуют явной очистки).

## События и компоненты

Компоненты - это функции, не элементы. Поскольку события DOM не существуют сами по себе, можно определить их в качестве параметров.

Давайте посмотрим, как объявляется дочерний компонент, в котором используются события.

```tsx
import { PropFunction } from '@builder.io/qwik';

interface CmpButtonProps {
  onClick$?: PropFunction<() => void>;
}

export const CmpButton = component$((props: CmpButtonProps) => {
  return (
    <button onDblclick$={props.onClick$}>
      <Slot />
    </button>
  );
});
```

С точки зрения Qwik, передача событий компоненту эквивалентна передаче параметров. В нашем примере мы объявляем все параметры в интерфейсе `CmpButtonProps`. В частности, обратите внимание на объявление `onClick$: PropFunction<() => void>`.

Использование компонента `<CmpButton>`:

```tsx
<CmpButton onClick$={() => store.cmpCount++}>{store.cmpCount}</CmpButton>
```

## Работа с QRL

Давайте рассмотрим вариант реализации вышеприведённого компонента `<CmpButton>`. В этом примере мы хотим продемонстрировать передачу компонентам функций обратных вызовов. Для этого мы создали дополнительный слушатель `onClick$`.

```tsx
interface CmpButtonProps {
  onClick$?: PropFunction<() => number>;
}

export const CmpButton = component$((props: CmpButtonProps) => {
  return (
    <button
      onDblclick$={props.onClick$}
      onClick$={async () => {
        const nu = await props?.onClick$();
        console.log('clicked', nu);
      }}
    >
      <Slot />
    </button>
  );
});
```

Обратите внимание, что мы можем передать метод `props.onClick$` непосредственно в атрибут `onDblclick$`, как показано на элементе `<button>` (см. атрибут `onDblclick$={props.onClick$}`). Это возможно потому, что как входной параметр `onClick$`, так и JSX-атрибут `onDblclick` имеют одинаковый тип `PropFunction<?>` (и оба имеют суффикс `$`).

Однако `props.onClick$` невозможно передать в `onClick$`, потому что типы не совпадают (это привело бы к ошибке типа: `onClick$={props.onClick$}`). Вместо этого `$` зарезервирован для внутренних замыканий. В нашем примере мы хотим, чтобы `console.log('clicked')` выполнился после функции обратного вызова `props.onClick`. Мы можем сделать это с помощью метода `props.onClick$()`. Этот метод выполнит:

  1. Ленивую загрузку кода;
  2. Восстановление состояния замыкания;
  3. Вызов замыкания.

Операция является асинхронной и поэтому возвращает промис, который мы можем разрешить с помощью оператора `await`.

## Восстановление состояния

```tsx
export const Counter = component$(() => {
  const store = useStore({ count: 0 });

  return <button onClick$={() => store.count++}>{store.count}</button>;
});
```

На первый взгляд может показаться, что Qwik просто лениво загружает функцию `onClick$`. Но важно понять, что Qwik делает ленивую загрузку замыкания раньше функции (замыкание - это функция, которая лексически фиксирует состояние внутри своих переменных, другими словами, замыкание переносит состояние, а функции - нет). Захват состояния - это то, что позволяет приложению Qwik просто возобновить работу с того места, где остановился сервер, потому что восстановленное замыкание переносит и состояние приложения.

В нашем случае замыкание `onClick$` захватывает `store`. Захват `store` позволяет приложению увеличивать свойство `count` при событии `click` без необходимости запуска пересчёта всего приложения. Давайте рассмотрим, как работает захват замыкания в Qwik.

HTML-код, сгенерированный приведённым выше кодом, будет выглядеть примерно так:

```html
<div>
  <button q:obj="1" on:click="./chunk-a.js#Counter_button_onClick[0]">0</button>
</div>
```

Обратите внимание, что атрибут `on:click` содержит три части информации:

1. `./chunk-a.js`: Файл, который должен быть лениво загружен;
2. `Counter_button_onClick`: Символ, который необходимо извлечь из лениво загруженного чанка;
3. `[0]`: Массив лексически захваченных ссылок на переменные (состояние закрытия).

В нашем случае `() => store.count++` захватывает только `store` и, следовательно, содержит только одну ссылку - `0`. `0` — это индекс в объекте `q:obj`, который содержит ссылку на реальный сериализованный объект, относящийся к `store` (механизм и синтаксис — деталь реализации, которая может измениться в любое время).

## Qwikloader

Для того чтобы браузер понимал синтаксис атрибута `on:click`, необходим небольшой JavaScript-скрипт, известный как Qwikloader. Qwikloader имеет небольшой размер (около 1 кб) и высокую скорость выполнения (около 5 мс). Скрипт Qwikloader встроен в HTML, поэтому он может быть быстро выполнен.
Когда пользователь взаимодействует с приложением, браузер запускает соответствующие события, которые всплывают в DOM. В корне DOM Qwikloader прослушивает события, а затем пытается найти соответствующий атрибут `on:<event>`. Если такой атрибут найден, то значение атрибута используется для определения места, откуда нужно загрузить, а затем выполнить код.

Подробности смотри в разделе [Qwikloader](./../../advanced/qwikloader/index.mdx).
