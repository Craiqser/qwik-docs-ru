---
title: Жизненный цикл
keywords: useEffect, hooks
contributors:
  - nnelgxorz
  - RATIU5
  - manucorporat
---

import diagram from './diagram2.svg';

# Хуки жизненного цикла

Благодаря [возобновляемости](/docs/concepts/resumable/index.mdx), жизнь компонентов и их жизненный цикл распространяются на сервер и браузер. Иногда компонент будет сначала отрисован на сервере, иногда - в браузере, однако в обоих случаях жизненный цикл будет одинаковым, только его выполнение происходит в разных средах.

Обычно **жизнь компонента начинается на сервере** (во время SSR или SSG), в этом случае хуки будут работать следующим образом:

```
  useTask$ --> RENDER --> useClientEffect$
                       |
| ------ SERVER ------ | ---- BROWSER ---- |
                       |
                  pause|resume
```

> **Заметьте**, что поскольку компонент был смонтирован на сервере, **только useClientEffect$() выполняется в браузере**. Это происходит потому, что браузер продолжает тот же жизненный цикл, который был приостановлен на сервере сразу после рендера и возобновлён в браузере.

Иногда компонент сначала монтируется/рендерится в браузере, например, когда пользователь SPA переходит на новую страницу или "модальный" компонент впервые появляется на странице. В этом случае жизненный цикл будет выглядеть следующим образом:

```
  useTask$ --> RENDER --> useClientEffect$

| --------------- BROWSER --------------- |
```

> **Заметьте**, что жизненный цикл точно такой же, но на этот раз все хуки выполняются в браузере, а не на сервере.

## `useTask$()`

- **Когда:** ДО первого рендера компонента и при изменении состояния отслеживания
- **Раз:** хотя бы раз
- **Платформа:** сервер и браузер

`useTask$()` регистрирует хук для выполнения при создании компонента, он будет запущен как минимум один раз либо на сервере, либо в браузере, в зависимости от того, где первоначально отображается компонент.

Кроме того, эта задача может быть реактивной и повторно выполняться при изменении какого-либо **отслеживаемого** [сигнала или хранилища](/docs/components/state/index.mdx), например, так:

```tsx
useTask$(({track}) => {
  track(() => store.count);
  // будет выполняться при монтировании компонента и каждый раз при изменении "store.count"
})
```

**Обратите внимание, что любое последующее выполнение всегда будет происходить в браузере**, потому что реактивность - это только для клиента.

```
  useTask$(track state) -> RENDER -> CLICK (state changes) -> RE-RUN useTask$(track state)
  ▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔            |                          ▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔
| --------- SERVER --------- | --------------- BROWSER --------------- |
                             |
                        pause|resume
```

> Если `useTask$()` не отслеживает состояние, она будет запущена **только один раз**, на сервере **или** в браузере (**но не там и там**), в зависимости от того, где первоначально отображается компонент. Эффективно использование в хуке "on mount".

`useTask$()` будет блокировать рендер компонента до тех пор, пока не разрешится его метод асинхронного обратного вызова, другими словами, задачи выполняются последовательно, даже если они асинхронны (одновременно выполняется только одна задача / задачи блокируют рендер).

### Пример

Функция `useTask$()` используется для наблюдения за свойством `state.count`. Любые изменения в `state.count` вызывают выполнение стрелочной функции, которая в свою очередь обновляет `state.doubleCount` до двойного значения `state.count`.

```tsx
import { component$, useStore, useTask$ } from '@builder.io/qwik';

export const Cmp = component$(() => {
  const store = useStore({
    count: 1,
    doubleCount: 0,
  });

  // эта задача будет вызвана ровно один раз, либо на сервере, либо в браузере
  useTask$(() => {
    console.log('component mounted');
  });

  // эта задача будет вызываться при монтировании и каждый раз, когда изменяется `store.count`
  useTask$(({ track }) => {
    const count = track(() => store.count);
    store.doubleCount = 2 * count;
  });

  return (
    <div>
      {store.count} / {store.doubleCount}
    </div>
  );
});
```

В примере выше используется функция `track` для отслеживания изменений в `() => store.count`. Обратный вызов будет выполняться один раз в SSR при монтировании компонента и каждый раз, когда `store.count` изменяется.

> Обратите внимание, что `useTask$()` выполняется **ДО** фактического рендера и на сервере, поэтому если вам нужно сделать какие-либо манипуляции с DOM, используйте вместо этого `useClientEffect$()`, который выполняется на клиенте после рендера.

### Когда использовать `useTask$()`

- Выполнение асинхронных задач перед рендером;
- Выполнение кода только один раз перед первым рендером компонента;
- Вычисление производного состояния из отслеживаемого состояния (не вызывая потенциального повторного рендера, как в `useClientEffect$`);
- Программное выполнение кода при изменении состояния.

> Обратите внимание, если вы думаете о загрузке данных (например, используя `fetch()`) внутри `useTask$`, то подумайте об использовании вместо этого [`useResource$()`](/docs/components/resource/index.mdx). Этот API более эффективен с точки зрения использования потоковой передачи SSR и параллельной выборки данных.

### Задача только для сервера/браузера

Иногда требуется запуск кода только либо на сервере, либо на клиенте. Этого можно достичь, используя флаги `isServer` и `isBrowser`, экспортируемые из `@builder.io/qwik/build`.

```tsx
import { isServer, isBrowser } from '@builder.io/qwik/build';

export const Cmp = component$(() => {
  const store = useStore({
    users: [],
  });
  useTask$(async () => {
    if (isServer) {
      // Если компонент монтируется на сервере, вызовите базу данных напрямую.
      store.users = await db.requestUsers();
    }
    if (isBrowser) {
      // Если компонент монтируется в браузере, получите пользователей через API.
      store.users = await fetchGetUsers();
    }
  });

  return (
    <>
      {store.users.map((user) => (
        <User user={user} />
      ))}
    </>
  );
});
```

> Но, как было сказано выше, для выборки данных рассмотрите возможность использования вместо этого [`useResource$()`](/docs/components/resource/index.mdx).

## `useClientEffect$()`

- **Когда:** ПОСЛЕ первого рендера компонента и при отслеживаемых изменениях состояния
- **Раз:** хотя бы раз
- **Платформа:** только браузер

Для всех компонентов, которые были смонтированы во время SSR (на сервере), `useClientEffect$()` будет запускаться сразу, то есть без взаимодействия с пользователем, но это поведение можно настроить!

```tsx
useClientEffect$(() => console.log('запускается в браузере'), {
  eagerness: 'visible' // 'load' | 'visible' | 'idle'
});
```

Это уникальная особенность Qwik, любой другой фреймворк будет выполнять этот и другой код как часть гидратации, но в Qwik вы можете указать, когда это произойдет:

- `"visible"`: (это значение по умолчанию) когда компонент становится видимым во вьюпорте (под капотом используется [Intersection Observer](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API)).
- `"load"`: когда документы завершают загрузку (событие документа "load");
- `"idle"`: после загрузки в первый момент, когда сайт простаивает. Под капотом он использует [`requestIdleCallback()`](https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback).

### Пример

```tsx
export const Timer = component$(() => {
  const store = useStore({
    count: 0,
  });
  useClientEffect$(() => {
    // Запускается только на клиенте.
    const timer = setInterval(() => {
      store.count++;
    }, 500);
    return () => {
      clearInterval(timer);
    };
  });
  return <>{store.count}</>;
});
```

> **ПРИМЕЧАНИЕ:** Не злоупотребляйте `useClientEffect$()`, когда та же логика может быть достигнута с помощью `useTask$()` или другими средствами. Спросите себя: действительно ли этот код должен выполняться в самом начале в браузере? Если ответ отрицательный, то `useClientEffect$()`, вероятно, не является правильным ответом.

### Когда использовать `useClientEffect$()`

Используйте этот хук, когда вам нужно запустить JS прямо во время загрузки страницы, даже если пользователь никогда не взаимодействует со страницей.

Например:

- Чтение DOM после рендера;
- Инициализация некоторых анимаций;
- Логика WebGL;
- Использование DOM API, например `localStorage`;
- Запуск некоторого кода без взаимодействия с пользователем, например, setInterval().

## Правила использования метода Use

При использовании хуков жизненного цикла необходимо придерживаться следующих правил:

- Они могут быть вызваны только в `component$`;
- Они могут быть вызваны только на верхнем уровне функции / контексте стрелочной функции, а не внутри ветвей или условных блоков;
- Они могут быть вызваны только из другого метода `use*$`, что позволяет создавать композицию.

```tsx
useHook(); // <-- ❌ не работает

export default component$(() => {
  useCustomHook(); // <-- ✅ работает
  if (condition) {
    useHook(); // <-- ❌ не работает
  }
  const myQrl = $(() => useHook()); // <-- ❌ не работает
  return <button onClick$={() => useHook()}></button>; // <-- ❌ не работает
});

const useCustomHook = () => {
  useHook(); // <-- ✅ работает
};
```
