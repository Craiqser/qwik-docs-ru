---
title: Жизненный цикл
contributors:
  - nnelgxorz
  - RATIU5
  - manucorporat
---

import diagram from './diagram2.svg';

# Хуки жизненного цикла

<img src={diagram}/>

## Правила

При использовании хуков жизненного цикла необходимо придерживаться следующих правил:

  - Они могут быть вызваны только внутри `component$`;
  - Они могут быть вызваны только на верхнем уровне контекста функции/стрелочной функции, а не внутри ветвей кода или условных блоков;
  - Они могут быть вызваны только из другого метода `use*$`, что позволяет создавать композицию.

```tsx
useHook() // <-- ❌ не работает

export default component$(() => {
  useHook() // <-- ✅ работает
  if (condition) {
    useHook() // <-- ❌ не работает
  }
  const myQrl = $(() => useHook()) // <-- ✅ работает
  return <button onClick$={() => useHook()}></button> // <-- ✅ работает
})

const useCustomHook = () => {
  useHook() // <-- ✅ работает
}
```

## `useMount$()`

`useMount$()` регистрирует хук, который будет выполняться при создании компонента. `useMount$()` будет блокировать рендеринг компонента до тех пор, пока функция обратного вызова `useMount$()` не разрешится (это часто используется для получения асинхронных данных и задержки рендеринга до их получения, гарантируя, что рендер компонента содержит данные).

Хотя `useMount$()` может выполняться как на сервере, так и на клиенте, она запускается ровно один раз (либо на сервере, либо на клиенте, в зависимости от того, где был первый рендер компонента).

Смотри также хук `useServerMount$()`, который имеет ту же семантику, но работает только на сервере.

### Пример

```tsx
export const Cmp = component$(() => {
  const store = useStore({
    users: [],
  });
  useMount$(async () => {
    // Этот код будет выполняться при создании компонента для получения данных.
    store.users = await db.requestUsers();
  });
  return (
    <>
      {store.users.map((user) => (
        <User user={user} />
      ))}
    </>
  );
});

interface User {
  name: string;
}

export function User(props: { user: User }) {
  return <div>Name: {props.user.name}</div>;
}
```

## `useServerMount$()`

`useServerMount$()` регистрирует серверный хук монтирования, который запускается на сервере только при первом монтировании компонента.

### Пример

```tsx
export const Cmp = component$(() => {
  const store = useStore({
    users: [],
  });
  useServerMount$(async () => {
    // Этот код выполнится ТОЛЬКО один раз на сервере, при монтировании компонента.
    store.users = await db.requestUsers();
  });
  return (
    <>
      {store.users.map((user) => (
        <User user={user} />
      ))}
    </>
  );
});

interface User {
  name: string;
}

export function User(props: { user: User }) {
  return <div>Name: {props.user.name}</div>;
}
```

## `useWatch$()`

Повторно запускает `watchFn` при изменении отслеживаемых данных.

`useWatch` используется для отслеживания изменений в наборе входных данных, и повторного выполнения `watchFn` при изменении этих данных.

`watchFn` выполняется только в том случае, если входные данные изменились. Для отслеживания данных используется функция `track`, которая перехватывает чтение свойств. Это создаёт подписки, которые вызовут повторный запуск `watchFn`.

Смотри также хук `useClientEffect$()`, который имеет ту же семантику, но работает только на клиенте.

### Пример

Функция `useWatch` используется для наблюдения за свойством `state.count`. Любые изменения в `state.count` вызывают выполнение `watchFn`, которая, в свою очередь, обновляет `state.doubleCount` до двойного значения `state.count`.

```tsx
export const Cmp = component$(() => {
  const store = useStore({
    count: 1,
    doubleCount: 0,
    debounced: 0,
  });
  // Double count watch
  useWatch$(({ track }) => {
    const count = track(() => store.count);
    store.doubleCount = 2 * count;
  });
  // Debouncer watch
  useWatch$(({ track }) => {
    const doubleCount = track(() => store.doubleCount);
    const timer = setTimeout(() => {
      store.debounced = doubleCount;
    }, 2000);
    return () => {
      clearTimeout(timer);
    };
  });

  return (
    <>
      <div>
        {store.count} / {store.doubleCount}
      </div>
      <div>{store.debounced}</div>
    </>
  );
});
```

## `useClientEffect$()`

Повторно запускает `watchFn` при изменении отслеживаемых входных данных.

Если `track` не используется, она будет выполнена ровно один раз.

### Пример

```tsx
export const Timer = component$(() => {
  const store = useStore({
    count: 0,
  });
  useClientEffect$(() => {
    // Запускается только на клиенте.
    const timer = setInterval(() => {
      store.count++;
    }, 500);
    return () => {
      clearInterval(timer);
    };
  });
  return <>{store.count}</>;
});
```
