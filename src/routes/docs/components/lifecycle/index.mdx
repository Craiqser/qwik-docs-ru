---
title: Жизненный цикл
keywords: useEffect, hooks
contributors:
  - nnelgxorz
  - RATIU5
  - manucorporat
---

import diagram from './diagram2.svg';

# Хуки жизненного цикла

## `useMount$()`

- **Триггер:** монтирование компонента
- **Когда:** перед рендером и ресурсами
- **Раз:** только один раз для каждого экземпляра компонента
- **Платформа:** сервер и браузер

`useMount$()` регистрирует хук, который будет выполняться при создании компонента. `useMount$()` будет блокировать рендеринг компонента до тех пор, пока функция обратного вызова `useMount$()` не разрешится (это часто используется для получения асинхронных данных и задержки рендеринга до их получения, гарантируя, что рендер компонента содержит данные).

Хотя `useMount$()` может выполняться как на сервере, так и на клиенте, она запускается ровно один раз (либо на сервере, либо на клиенте, в зависимости от того, где был первый рендер компонента).

Смотри также хук `useServerMount$()`, который имеет ту же семантику, но работает только на сервере.

### Пример

```tsx
export const Cmp = component$(() => {
  const store = useStore({
    users: [],
  });
  useMount$(async () => {
    // Этот код будет выполняться при создании компонента для получения данных.
    store.users = await db.requestUsers();
  });
  return (
    <>
      {store.users.map((user) => (
        <User user={user} />
      ))}
    </>
  );
});

interface User {
  name: string;
}

export function User(props: { user: User }) {
  return <div>Name: {props.user.name}</div>;
}
```

### Когда использовать `useMount$()`

Вам требуется выполнить некоторый код ТОЛЬКО при монтировании компонента, один раз.

## `useServerMount$()`

- **Триггер:** монтирование компонента
- **Когда:** перед рендером и ресурсами
- **Раз:** только один раз для каждого экземпляра компонента
- **Платформа:** только сервер

`useServerMount$()` регистрирует серверный хук монтирования, который запускается на сервере только при первом монтировании компонента.

### Пример

```tsx
export const Cmp = component$(() => {
  const store = useStore({
    users: [],
  });
  useServerMount$(async () => {
    // Этот код выполнится ТОЛЬКО один раз на сервере, при монтировании компонента.
    store.users = await db.requestUsers();
  });
  return (
    <>
      {store.users.map((user) => (
        <User user={user} />
      ))}
    </>
  );
});

interface User {
  name: string;
}

export function User(props: { user: User }) {
  return <div>Name: {props.user.name}</div>;
}
```

## `useClientMount$()`

- **Триггер:** монтирование компонента
- **Когда:** перед рендером и ресурсами
- **Раз:** только один раз для каждого экземпляра компонента
- **Платформа:** только браузер

`useClientMount$()` регистрирует хук для монтирования на клиента, который запускается в браузере только при первом монтировании компонента.

### Пример

```tsx
export const Cmp = component$(() => {
  const store = useStore({
    option: string,
  });
  useClientMount$(() => {
    // Этот код будет запущен в браузере ТОЛЬКО один раз, когда компонент будет смонтирован.
    store.option = localStorage.getItem('option');
  });
  return (
    <>
      Localstore: {store.option}
    </>
  );
});
```

## `useWatch$()`

- **Триггер:** монтирование компонента и по отслеживаемым изменениям состояния
- **Когда:** перед рендером и ресурсами
- **Раз:** хотя бы раз
- **Платформа:** сервер и браузер

Как и `useMount$()`, хук вызывается в первый раз, когда компонент монтируется, однако он может быть вызван несколько раз, если (и только если) он отслеживает изменения [сигнала и хранилища](/docs/components/state/index.mdx).

> `useWatch$()` отличается от useEffect в React тем, что `useWatch` также выполняется во время SSR и перед рендером.

### Пример

Функция `useWatch$()` используется для наблюдения за свойством `state.count`. Любые изменения в `state.count` вызывают выполнение `watchFn`, которая, в свою очередь, обновляет `state.doubleCount` до двойного значения `state.count`.

```tsx
import { component$, useStore, useWatch$ } from '@builder.io/qwik';

export const Cmp = component$(() => {
  const store = useStore({
    count: 1,
    doubleCount: 0,
  });

  useWatch$(({ track }) => {
    const count = track(() => store.count);
    store.doubleCount = 2 * count;
  });

  return (
    <>
      <div>
        {store.count} / {store.doubleCount}
      </div>
    </>
  );
});
```

В примере выше используется функция `track` для отслеживания изменений в `() => store.count`. Обратный вызов будет выполняться один раз в SSR при монтировании компонента и каждый раз, когда `store.count` изменяется.

> Обратите внимание, что `useWatch$()` выполняется ДО фактического рендера и на сервере, поэтому ручные манипуляции с DOM нужно выполнять с осторожностью.

> См. также хук `useClientEffect$()`, который имеет схожую семантику, но запускается на клиенте только после рендера.

### Когда использовать `useWatch$()`

Вы хотите изменить какое-то состояние или выполнить какое-то действие при изменении состояния. То есть, у вас должны быть побочные эффекты.

> Обратите внимание, если вы хотите загрузить некоторые данные (например, с помощью fetch()), чтобы затем использовать их в своём компоненте, посмотрите на [`useResource$()`](/docs/components/resource/index.mdx). Этот API будет ещё более эффективно использовать потоковую передачу SSR и параллелизим.

## `useClientEffect$()`

- **Триггер:** монтирование компонента и по отслеживаемым изменениям состояния
- **Когда:** после рендера
- **Раз:** хотя бы раз
- **Платформа:** только браузер

Аналогично `useWatch$()` или `useMount$()` этот хук также будет запущен хотя бы один раз, но он никогда не будет ЗАПУЩЕН на сервере, то есть будет запущен только в браузере.

Для всех компонентов, которые были смонтированы во время SSR (на сервере), `useClientEffect$()` будет выполняться сразу, то есть без взаимодействия с пользователем, но это поведение может быть настроено!

```tsx
useClientEffect$(() => console.log('запускается в браузере'), {
  eagerness: 'visible' // 'load' | 'visible' | 'idle'
});
```

Это уникальная особенность Qwik, любой другой фреймворк будет выполнять этот и другой код как часть гидратации, но в Qwik мы можем указать, когда это произойдет:

- `"visible"`: когда компонент становится видимым во вьюпорте (под капотом используется [Intersection Observer](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API)). Это значение по умолчанию.
- `"load"`: когда документы завершают загрузку (событие документа "load");
- `"idle"`: после загрузки в первый момент, когда сайт простаивает. Под капотом он использует [`requestIdleCallback()`](https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback).

### Пример

```tsx
export const Timer = component$(() => {
  const store = useStore({
    count: 0,
  });
  useClientEffect$(() => {
    // Запускается только на клиенте.
    const timer = setInterval(() => {
      store.count++;
    }, 500);
    return () => {
      clearInterval(timer);
    };
  });
  return <>{store.count}</>;
});
```

> **ПРИМЕЧАНИЕ:** Не злоупотребляйте `useClientEffect$()`, когда та же логика может быть достигнута с помощью `useWatch$()` или другими средствами. Спросите себя: действительно ли этот код должен выполняться в самом начале в браузере? Если ответ отрицательный, то `useClientEffect$()`, вероятно, не является правильным ответом.

> Как это сравнимо с `useEffect()` в React? Оба API имеют общую семантику, но хотя оба выполняются ПОСЛЕ рендера, `useClientEffect$()` может выполняться и независимо от рендера.

### Когда использовать `useClientEffect$()`

Вам нужно запускать JS прямо во время загрузки страницы, даже если пользователь не взаимодействует со страницей.

- Инициализация некоторых анимаций;
- Логика WebGL;
- Чтение `локальных хранилищ`;
- Выполнение кода без взаимодействия с пользователем.

## Диаграмма

<img src={diagram}/>

## Правила использования метода Use

При использовании хуков жизненного цикла необходимо придерживаться следующих правил:

- Они могут быть вызваны только в `component$`;
- Они могут быть вызваны только на верхнем уровне функции / контексте стрелочной функции, а не внутри ветвей или условных блоков;
- Они могут быть вызваны только из другого метода `use*$`, что позволяет создавать композицию.

```tsx
useHook() // <-- ❌ не работает

export default component$(() => {
  useCustomHook() // <-- ✅ работает
  if (condition) {
    useHook() // <-- ❌ не работает
  }
  const myQrl = $(() => useHook()) // <-- ❌ не работает
  return <button onClick$={() => useHook()}></button> // <-- ❌ не работает
})

const useCustomHook = () => {
  useHook() // <-- ✅ работает
}
```
