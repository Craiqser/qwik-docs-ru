---
title: Жизненный цикл
keywords: useEffect, hooks
contributors:
  - nnelgxorz
  - RATIU5
  - manucorporat
---

import diagram from './diagram2.svg';

# Хуки жизненного цикла

Благодаря [возобновляемости](/docs/concepts/resumable/index.mdx), жизнь компонентов и их жизненный цикл распространяются на сервер и браузер. Иногда компонент будет сначала рендериться на сервере, иногда - в браузере, однако в обоих случаях жизненный цикл будет одинаковым, только его выполнение происходит в разных средах.

**В Qwik всего 3 стадии жизненного цикла:**

- `Task` - запускается перед рендером и при изменении отслеживаемого состояния;
- `Render` - запускается после `Task` и перед `VisibleTask`;
- `VisibleTask` - запускается после `Render` и когда компонент становится видимым.

```
  useTask$ ------> RENDER -----> useVisibleTask$
                            |
| --- SERVER or BROWSER --- | ----- BROWSER ----- |
                            |
                       pause|resume
```

**СЕРВЕР**: Обычно **жизнь компонента начинается на сервере** (во время SSR или SSG), в этом случае `useTask$` и `RENDER` будут выполняться на сервере, а затем в браузере запустится `VisibleTask` после того, как компонент станет видимым.

> **Заметьте**, что поскольку компонент был смонтирован на сервере, **в браузере выполняется только useVisibleTask$()**. Это происходит потому, что браузер продолжает тот же жизненный цикл, который был приостановлен на сервере после рендера и возобновлён в браузере.

**БРАУЗЕР**: Иногда компонент первоначально монтируется/рендерится в браузере, например, когда пользователь SPA переходит на новую страницу или когда "модальный" компонент первоначально появляется на странице. В этом случае жизненный цикл будет выглядеть следующим образом:

```
  useTask$ --> RENDER --> useVisibleTask$

| ---------------- BROWSER --------------- |
```

> **Заметьте**, что жизненный цикл точно такой же, но на этот раз все хуки выполняются в браузере, а не на сервере.

## `useTask$()`

- **Когда:** ДО первого рендера компонента и при изменении состояния отслеживания
- **Раз:** хотя бы раз
- **Платформа:** сервер и браузер

`useTask$()` регистрирует хук для выполнения при создании компонента, он будет запущен как минимум один раз либо на сервере, либо в браузере, в зависимости от того, где первоначально отображается компонент.

Кроме того, эта задача может быть реактивной и повторно выполняться при изменении какого-либо **отслеживаемого** [сигнала или хранилища](/docs/components/state/index.mdx), например, так:

```tsx
useTask$(({ track }) => {
  track(() => store.count);
  // будет выполняться при монтировании компонента и каждый раз при изменении "store.count"
});
```

**Обратите внимание, что любое последующее выполнение всегда будет происходить в браузере**, потому что реактивность - это только для клиента.

```
  useTask$(track state) -> RENDER -> CLICK (state changes) -> RE-RUN useTask$(track state)
  ▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔            |                          ▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔
| --------- SERVER --------- | --------------- BROWSER --------------- |
                             |
                        pause|resume
```

> Если `useTask$()` не отслеживает состояние, она будет запущена **только один раз**, на сервере **или** в браузере (**но не там и там**), в зависимости от того, где первоначально отображается компонент. Эффективно использование в хуке "on mount".

`useTask$()` будет блокировать рендер компонента до тех пор, пока не разрешится его метод асинхронного обратного вызова, другими словами, задачи выполняются последовательно, даже если они асинхронны (одновременно выполняется только одна задача / задачи блокируют рендер).

### Пример

Функция `useTask$()` используется для наблюдения за свойством `state.count`. Любые изменения в `state.count` вызывают выполнение стрелочной функции, которая в свою очередь обновляет `state.doubleCount` до двойного значения `state.count`.

```tsx
import { component$, useSignal, useTask$ } from '@builder.io/qwik';

export const Cmp = component$(() => {
  const count = useSignal(1);
  const doubleCount = useSignal(0);

  // эта задача будет вызвана ровно один раз, либо на сервере, либо в браузере
  useTask$(() => {
    console.log('component mounted');
  });

  // эта задача будет вызываться при монтировании и каждый раз, когда изменяется `store.count`
  useTask$(({ track }) => {
    const count = track(() => count.value);
    doubleCount.value = 2 * count;
  });

  return (
    <div>
      {count.value} / {doubleCount.value}
    </div>
  );
});
```

В примере выше используется функция `track` для отслеживания изменений в `() => count.value`. Обратный вызов будет выполняться один раз в SSR при монтировании компонента и каждый раз, когда `count.value` изменяется.

> Обратите внимание, что `useTask$()` выполняется **ДО** фактического рендера и на сервере, поэтому если вам нужно сделать какие-либо манипуляции с DOM, используйте вместо этого `useVisibleTask$()`, который выполняется на клиенте после рендера.

### Когда использовать `useTask$()`

- Выполнение асинхронных задач перед рендером;
- Выполнение кода только один раз перед первым рендером компонента;
- Вычисление производного состояния из отслеживаемого состояния (не вызывая потенциального повторного рендера, как в `useVisibleTask$`);
- Программное выполнение кода при изменении состояния.

> Обратите внимание, если вы думаете о загрузке данных (например, используя `fetch()`) внутри `useTask$`, то подумайте об использовании вместо этого [`useResource$()`](/docs/components/resource/index.mdx). Этот API более эффективен с точки зрения использования потоковой передачи SSR и параллельной выборки данных.

### Задача только для сервера/браузера

Иногда требуется запуск кода только либо на сервере, либо на клиенте. Этого можно достичь, используя флаги `isServer` и `isBrowser`, экспортируемые из `@builder.io/qwik/build`.

```tsx
import { isServer, isBrowser } from '@builder.io/qwik/build';

export const Cmp = component$(() => {
  const users = useSignal([]);
  useTask$(async () => {
    if (isServer) {
      // Если компонент монтируется на сервере, вызовите базу данных напрямую.
      users.value = await db.requestUsers();
    }
    if (isBrowser) {
      // Если компонент монтируется в браузере, получите пользователей через API.
      users.value = await fetchGetUsers();
    }
  });

  return (
    <>
      {users.value.map((user) => (
        <User user={user} />
      ))}
    </>
  );
});
```

> Но, как было сказано выше, для получения данных рассмотрите возможность использования вместо этого [`useResource$()`](/docs/components/resource/index.mdx).

## `useVisibleTask$()`

- **Когда:** как только компонент становится видимым в браузере и при отслеживаемых изменениях состояния
- **Раз:** хотя бы раз
- **Платформа:** только браузер

`useVisibleTask$()` регистрирует хук для выполнения при появлении компонента в области просмотра. Он выполнится в браузере по крайней мере один раз, и может реактивно выполняться при изменении какого-либо **отслеживаемого** [сигнала или состояния](/docs/components/state/index.mdx), например, так:

```tsx
useVisibleTask$(({ track }) => {
  track(() => store.count);
  // выполняется, когда компонент становится видимым, и при каждом изменении "store.count".
  console.log('запущен в браузере');
});
```

Под капотом `useVisibleTask$()` создает DOM-слушатель, который использует [Intersection Observer](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API) для отслеживания того момента, когда компонент становится видимым в области просмотра.

Однако, эту `стратегию` можно изменить и запустить хук, например, когда объект `document` будет полностью загружен.

```tsx
useVisibleTask$(() => console.log('запущен в браузере'), {
  strategy: 'document-ready', // 'intersection-observer' | 'document-idle'
});
```

Это уникальная особенность Qwik, любой другой фреймворк будет выполнять этот и другой код как часть гидратации, но в Qwik вы можете указать, когда это произойдет:

- `"intersection-observer"`: (значение по умолчанию) когда компонент становится видимым в области просмотра (используется [Intersection Observer](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API));
- `"document-ready"`: когда документ завершает загрузку (событие документа "load");
- `"document-idle"`: после загрузки, в момент простоя браузера. Под капотом используется [`requestIdleCallback()`](https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback).

### Пример

```tsx
export const Timer = component$(() => {
  const count = useSignal(0);
  useVisibleTask$(() => {
    // Запускается только на клиенте.
    const timer = setInterval(() => {
      count.value++;
    }, 500);
    return () => {
      clearInterval(timer);
    };
  });
  return <>{count.value}</>;
});
```

### Когда использовать `useVisibleTask$()`

> **ПРИМЕЧАНИЕ:** Не злоупотребляйте `useVisibleTask$()`, когда та же логика может быть достигнута с помощью `useTask$()` или другими средствами. Спросите себя: действительно ли этот код должен начать своё выполнение в браузере? Если ответ отрицательный, то `useVisibleTask$()`, вероятно, не является правильным ответом.

Как следует из названия, хук `useVisibleTask$()` полезен когда нужно выполнить некоторый код в момент появления компонента в области просмотра. Это полезно для:

- Запуск кода ДО взаимодействия пользователя с приложением, например, инициализация анимации или выполнение любой другой логики;
- Чтение DOM после рендера;
- Логика WebGL;

## Правила использования use-методов

При использовании хуков жизненного цикла необходимо придерживаться следующих правил:

- Они могут быть вызваны только на корневом уровне `component$` (не внутри условных блоков);
- Они могут быть вызваны только в корне другого метода `use*`, допускающего композицию.

```tsx
useHook(); // <-- ❌ не работает

export default component$(() => {
  useCustomHook(); // <-- ✅ работает
  if (condition) {
    useHook(); // <-- ❌ не работает
  }
  useTask$(() => {
    useNavigate(); // <-- ❌ не работает
  });
  const myQrl = $(() => useHook()); // <-- ❌ не работает
  return <button onClick$={() => useHook()}></button>; // <-- ❌ не работает
});

function useCustomHook() {
  useHook(); // <-- ✅ does work
  if (condition) {
    useHook(); // <-- ❌ does not work
  }
}
```
