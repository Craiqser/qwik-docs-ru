---
title: Рендер
contributors:
  - the-r3aper7
  - RATIU5
  - manucorporat
  - forresst
  - adamdbradley
  - zanettin
  - cunzaizhuyi
  - Pika-Pool
  - Kesmek
  - Craiqser
---

# Рендер

Рендер — это процесс обновления DOM, основанный на:

1. Изменениях в состоянии приложения;
2. Шаблонах компонентов.

Уникальность Qwik заключается в том, что он знает как выполнять рендер шаблонов вне очереди, и асинхронно.

- **Вне очереди**: это означает, что Qwik не требует, чтобы родительский или дочерний компоненты рендерились при рендере одного из них.
- **Асинхронно**: это означает, что функция Qwik `render` понимает, что когда может потребоваться загрузка дочерних компонентов, и делает операцию рендера асинхронной.

Простой пример со счётчиком:

```tsx
import { component$, useSignal } from '@builder.io/qwik';

export const Counter = component$(() => {
  const count = useSignal(0);

  return <button onClick$={() => count.value++}>{count.value}</button>;
});
```

После рендеринга фрагмент HTML может выглядеть примерно так:

```html
<div>
  <button q:obj="123" on:click="./chunk-a.js#Counter_button_click[0]">0</button>
</div>
```

- Информация по `$` - [`$` и правила оптимизатора](../../advanced/optimizer/index.mdx).
- Информация по `q:obj` - [Сериализация](../../concepts/resumable/index.mdx).
- Информация по `on:click` - [Qwikloader](../../advanced/qwikloader/index.mdx).

## JSX

Для выражения шаблона компонента Qwik использует JSX. Обсуждение JSX выходит за рамки данного документа, но Qwik JSX должен показаться вам очень знакомым, если вы использовали JSX в других фреймворках. По этой причине давайте сосредоточимся на том, в чём различия Qwik JSX.

## Рендер дочерних компонентов

Qwik лениво загружает компоненты по мере необходимости. Чтобы минимизировать количество компонентов для загрузки, Qwik спускается в дочерние компоненты только в том случае, если изменились параметры компонента.

```tsx
import { component$, useSignal } from '@builder.io/qwik';

export const Parent = component$(() => {
  const count = useSignal(0);
  const step = useSignal(1);

  return (
    <>
      <button onClick$={() => (step.value *= -1)}>направление</button>
      <button onClick$={() => (count.value += step.value)}>{step.value}</button>
      <Greeter name={'Мир_' + count.value} />
    </>
  );
});

export const Greeter = component$((props: { name: string }) => {
  return <span>Привет, {props.name}</span>;
});
```

В приведенном выше примере есть две кнопки:

1. Нажатие первой кнопки изменяет направление шага счётчика (`store.step` переключается между `+1` и `-1`). Изменение `store` требует выполнения функции `OnRender` компонента. Результирующий JSX обновляет DOM, чтобы показать `+1` или `-1`. Однако изменение направления шага счётчика не изменит свойства в `<Greeter name={'Мир_' + store.count}/>`. По этой причине Qwik не будет спускаться в компонент `<Greeter>`, поэтому шаблон приветствия не нужно загружать или выполнять. Такая агрессивная обрезка позволяет Qwik свести к минимуму количество кода, необходимого для отображения компонента.

2. Нажатие второй кнопки увеличивает (или уменьшает) значение `store.count`. Это, в свою очередь, приводит к изменению свойства в `<Greeter name={'Мир_' + store.count}/>`. Изменение свойства означает, что Qwik спустится в компонент `<Greeter>` и сделает рендер. Однако, возможно, что Qwik ещё не будет иметь ссылки на дочерний компонент. В этом случае Qwik отложит загрузку компонента и продолжит рендеринг, как только станет доступна функция рендеринга компонента.

### Рендер с помощью `.map()`

Во многих случаях вы захотите рендерить компоненты, сопоставив массив в функции рендера с помощью `data.map()`. В этих случаях требуется предоставить ключ к первому дочернему элементу функции сопоставления.

```tsx
import { component$ } from '@builder.io/qwik';

export const Parent = component$(() => {
  return (
    <>
      {data.map(({ content, uniqueKey }) => (
        <div key={uniqueKey}>
          <p>{content}</p>
        </div>
      ))}
    </>
  );
});
```

> Примечание: не рекомендуется использовать индекс массива в качестве ключа, если вы не можете гарантировать, что массив не будет меняться. Всегда предпочтительнее использовать в качестве ключа какой-либо уникальный идентификатор из данных.

### `dangerouslySetInnerHTML`

Qwik предлагает для HTML-элементов атрибут под названием `dangerouslySetInnerHTML` в качестве замены вызова `innerHTML` в DOM. Из-за возможности межсайтового скриптинга (XSS) при рендере недостоверного содержимого, вы должны использовать этот атрибут, чтобы помнить о том, что эта операция может быть опасной.

```tsx
<div dangerouslySetInnerHTML={content}></div>
```

## `render()` является асинхронным

Приведённые выше примеры демонстрируют, почему процесс рендеринга должен быть асинхронным. Важно, чтобы конвейер рендеринга мог лениво загружать дочерние компоненты. Ленивая загрузка - это асинхронная операция; поэтому рендеринг должен быть асинхронным. На практике это означает, что функция `render()` возвращает промис.

Большинство фреймворков текущего поколения имеют синхронный `render()`. Синхронный рендеринг не может так просто справиться с асинхронной загрузкой кода, поэтому он требует чтобы все зависимые компоненты были представлены до начала рендеринга.

## Буферизация обновлений DOM

Асинхронный характер `render()` означает, что пользователи могут увидеть промежуточный рендеринг пользовательского интерфейса по мере загрузки компонентов. Видеть промежуточное состояние нежелательно, поэтому Qwik буферизует все обновления DOM и применяет эти операции только после загрузки всех компонентов и выполнения их JSX-функций. В результате пользовательский интерфейс будет обновляться как атомарная операция, и пользователь не увидит промежуточных шагов.
