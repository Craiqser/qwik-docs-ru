---
title: Лучшие практики
contributors:
  - mhevery
  - the-r3aper7
  - manucorporat
  - jakovljevic-mladen
  - kerbelp
  - wfairclough
  - cunzaizhuyi
  - reemardelarosa
  - un33k
---

# Лучшие практики

## Избегайте регистрации событий с помощью `useVisibleTask$()`.

> ⚠ Используйте `useVisibleTask$()` с осторожностью ⚠

**`Неоптимальная реализация`**:

```tsx
useVisibleTask$(() => {
  const listener = (event) => {
    const mouseEvent = event as MouseEvent;
    console.log(mouseEvent.x, mouseEvent.y);
  };
  document.addEventListener('mousemove', listener);

  return () => {
    document.removeEventListener('mousemove', listener)
  };
});
```

**`Проблема`**:

Приведённая выше реализация заставляет сразу загружать больше JavaScript-кода, вместо того, чтобы точечно реагировать на события пользователя. Повышение предварительной загрузки JavaScript приводит к снижению производительности приложения.

Кроме того, это требует от разработчиков более глубокого осознания отношений между сервером и клиентом, несмотря на первоначальное предпочтение `use > Visible < Task`.

В идеале фреймворк должен минимизировать необходимость для разработчиков фокусироваться на этом аспекте.

Более того, данная реализация требует ручной очистки слушателя события, что создаёт дополнительные усилия для разработчиков.

**`Оптимальная реализация`**:

```tsx
useOnDocument(
  'mousemove',
  $((event) => {
    const mouseEvent = event as MouseEvent;
    console.log(mouseEvent.x, mouseEvent.y);
    // Вручную очищать слушатель события не надо!
  })
);
```

Если вы сомневаетесь, используйте вместо `useVisibleTask$()`:
- `useOn()`: слушает события на корневом элементе `текущего компонента`;
- `useOnWindow()`: слушает события на объекте `window`;
- `useOnDocument()`: слушает события на объекте `document`.

> Подробнее:
-
> - [Документация useOn / useOnDocument / useOnWindow](/docs/(qwik)/components/events/index.mdx#useon-hooks)
> - [Пример](../../../../tutorial/hooks/use-on/#example)
> - [Руководство](../../../../tutorial/events/programmatic/)

---

## Избегайте доступа к `location` из объекта `window`.

⚠ Не обращайтесь напрямую к `window.location` ⚠

**`Неоптимальная реализация`**:

```tsx
useVisibleTask$(()=> {
    if (window.location.href).includes('foo') {
        //...делаем что-либо
    }
})
```

```tsx
// (в корне компонента)
if (typeof window !== "undefined") {
    const queryParams = new URLSearchParams(window.location.search);
    const query: Record<string, string> = {};
    queryParams.forEach((value, key) => {
        query[key] = value;
    })
    doTheThing(query);
}
```

**`Проблема`**:

Многие действия, связанные с информацией о местоположении, могут быть выполнены во время первоначального рендера на стороне сервера, в результате чего получается чистый HTML без каких-либо накладных расходов на JavaScript.

Заставляя эту логику работать на стороне клиента, мы увеличиваем количество JavaScript-кода, требующего немедленной загрузки.

Использование шаблона `if typeof window !== "undefined"` может привести к тому, что код будет пропущен. На сервере этот блок кода будет пропущен, поскольку там объект `window` не определён.

Хотя разработчики могут привыкнуть к тому, что код выполняется дважды, Qwik устраняет эту необходимость, предлагая более эффективный подход.

**`Оптимальная реализация`**:

```tsx
const location = useLocation();

if (location.url.href.includes('foo')) {
  //...делаем что-либо
}
```

```tsx
const location = useLocation();

doTheThing(location.url.searchParams);
```

## ИСКЛЮЧЕНИЕ

При использовании SSG для статических файлов неизбежно полагаться на сервер без текущей информации о местоположении во время сборки.

Однако будьте осторожны! Если требуемая информация (например, параметры запроса) не нужна до тех пор, пока не произойдет событие пользователя, включите проверку в код обработки событий.

Такой подход помогает предотвратить немедленную загрузку JavaScript-кода и повышает производительность.

> Смотри: [Документация useLocation()](/docs/(qwikcity)/api/index.mdx#uselocation)
