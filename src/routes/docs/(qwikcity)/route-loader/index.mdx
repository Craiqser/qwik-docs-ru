---
title: Qwik City - routeLoader$()
contributors:
  - manucorporat
---

# `routeLoader$()`

Загрузчики маршрута позволяют передавать данные с сервера компонентам Qwik. По этой причине загрузчики маршрута в Qwik всегда следует понимать в контексте **загрузки данных на сервере, которые впоследствии используются компонентом Qwik**. Если вы хотите создать конечную точку RESTful, то ознакомьтесь с руководством по [конечным точкам](../endpoints/index.mdx).

Они ведут себя как серверные функции RPC, которые могут вызываться компонентами Qwik во время рендера.

## Объявление загрузчика маршрута

Загрузчики маршрута могут быть объявлены только внутри папки `src/routes`, в файле `layout.tsx` или `index.tsx`, и они ДОЛЖНЫ быть экспортированы.

```tsx title="src/routes/layout.tsx"
import { routeLoader$ } from '@builder.io/qwik-city';

export const useProductData = routeLoader$(async () => {
  const res = await fetch('https://.../products');
  const product = await res.json();
  return product;
});
```

> `routeLoader$`-ы не являются конечными точками, это внутренний канал связи между сервером и компонентами Qwik. Кроме того, загрузчики маршрута должны возвращать сериализуемое JSON-значение.

## Использование `routeLoader$`

`routeLoader$`-ы могут использоваться любым компонентом приложения, если загрузчик объявлен в файле `layout.tsx` или `index.tsx`, который является частью существующего маршрута.

```tsx title="src/routes/index.tsx"
import { routeLoader$ } from '@builder.io/qwik-city';
import { component$ } from '@builder.io/qwik';

export const useProductData = routeLoader$(async () => {
  const res = await fetch('https://.../product');
  const product = await res.json() as Product;
  return product;
});

export default component$(() => {
  // Получение реактивного сигнала данных загрузчика
  const signal = useProductData(); // Signal<Product>
  return <div>Наименование товара: {signal.value.product.name}</div>;
});
```

> Может показаться, что `useGetServerTime()` инициирует получение данных сервера при рендере компонента. Но в действительности, `routeLoader$`, связанный с `useGetServerTime`, немедленно выполняется при HTTP-запросе. Таким образом, асинхронная работа по получению данных с сервера может быть начата как можно раньше (функция `routeLoader$` немедленно вызывается при HTTP запросе, независимо от того, вызвана ли `useGetServerTime()` в компоненте). По этой причине они разрешены только в папке `src/routes`, в файлах `layout.tsx` или `index.tsx`.

## Несколько `routeLoader$`-ов

В приложении разрешено использовать несколько `routeLoader$`-ов, и их можно использовать в любом компоненте Qwik. **Вы даже можете объявить несколько загрузчиков маршрута в одном файле**.

```tsx title="src/routes/layout.tsx"
import { component$ } from '@builder.io/qwik';
import { routeLoader$ } from '@builder.io/qwik-city';
import { Footer } from '../components/footer.tsx';

export const useProductData = routeLoader$(async () => {
  const res = await fetch('https://.../product');
  const product = await res.json() as Product;
  return product;
});

export default component$(() => {
  const signal = useProductData();
  return (
    <main>
      <Slot />
      <Footer />
    </main>
  );
});
```

```tsx title="src/components/footer.tsx"
import { component$ } from '@builder.io/qwik';

// Импорт загрузчика из макета
import { useProductData } from '../routes/layout.tsx';

export const Footer = component$(() => {
  // Использование данных загрузчика
  const signal = useProductData();
  return <footer>Наименование товара: {signal.value.product.name}</footer>;
});
```

Приведённый выше пример показывает использование `useProductData()` в двух разных компонентах и в разных файлах. Это намеренное поведение.

```tsx title="src/routes/admin/index.tsx"
import { component$ } from '@builder.io/qwik';
import { routeLoader$ } from '@builder.io/qwik-city';

export const useLoginStatus = routeLoader$(async ({cookie}) => {
  return {
    isUserLoggedIn: checkCookie(cookie)
  }
});

export const useCurrentUser = routeLoader$(async ({cookie}) => {
  return {
    user: currentUserFromCookie(cookie)
  }
});

export default component$(() => {
  const loginStatus = useLoginStatus();
  const currentUser = useCurrentUser();
  return (
    <section>
      <h1>Администратор</h1>
      {loginStatus.value.isUserLoggedIn ? (
        <p>Привет, {currentUser.value.user.name}</p>
      ) : (
        <p>Вы не авторизованы</p>
      )}
    </section>
  );
});
```

Приведённый выше пример показывает использование двух `routeLoader$`-ов в одном файле. Общий загрузчик `useLoginStatus` используется для проверки того, вошёл ли пользователь в систему, а более специфический загрузчик `useCurrentUser` используется для получения данных пользователя.

## Контекст загрузчика маршрута

Как и обработчики запросов, такие как `onRequest` и `onGet`, `routeLoader$`-ы имеют доступ к объекту `RequestEvent`, который содержит информацию о текущем запросе.

Эта информация пригодится, когда загрузчику необходимо вернуть данные по условию на основе запроса или ему необходимо вручную переопределить статус ответа, заголовки или тело.

```tsx
import { routeLoader$ } from '@builder.io/qwik-city';

export const useProductRecommendations = routeLoader$(
  async ({ headers, cookie, url, method, params }) => {
    console.log('Request headers:', headers);
    console.log('Request cookies:', cookie);
    console.log('Request url:', url);
    console.log('Request method:', method);
    console.log('Request params:', params);

    // Используйте детали запроса для получения персонализированных данных
    const res = fetch(`https://.../recommendations?user=${params.user}`);
    const products = await res.json() as Product[];

    return products;
  }
);
```

## Когда использовать загрузчик маршрута?

Загрузчик маршрута следует использовать, когда вам нужно предоставить серверные данные вашим Qwik-компонентам. Например, если вам нужно получить некоторые данные из базы данных или API, вы можете использовать для этого загрузчик маршрута.

Вы не должны использовать загрузчик маршрута для создания REST API, для этого вам лучше использовать [конечную точку](../endpoints/index.mdx), которая позволяет вам иметь более полный контроль над заголовками и телом ответа.
