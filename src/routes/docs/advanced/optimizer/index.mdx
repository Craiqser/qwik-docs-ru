---
title: Правила оптимизатора
contributors:
  - the-r3aper7
  - manucorporat
  - adamdbradley
---

# Оптимизатор

Философия Qwik заключается в том, чтобы как можно дольше откладывать загрузку кода. Для этого Qwik полагается на оптимизатор, который перестраивает код для ленивой загрузки. Оптимизатор - это преобразование на уровне кода, которое выполняется как часть работы Rollup (оптимизатор написан на языке Rust для мгновенной производительности и доступен как WASM).

Оптимизатор ищет `$` и применяет преобразование, которое извлекает выражение, следующее за `$`, и превращает его в лениво загружаемый и импортируемый символ.

Для начала рассмотрим простой пример `Counter`:

```tsx
export const Counter = component$(() => {
  const store = useStore({ count: 0 });

  return <button onClick$={() => store.count++}>{store.count}</button>;
});
```

Приведённый выше код представляет собой то, как разработчик пишет компонент. Ниже приведены преобразования, которые оптимизатор применяет к коду, чтобы сделать его пригодным для ленивой загрузки.

```tsx
const Counter = component(qrl('./chunk-a.js', 'Counter_onMount'));
```

`chunk-a.js`:

```tsx
export const Counter_onMount = () => {
  const store = useStore({ count: 0 });
  return <button onClick$={qrl('./chunk-b.js', 'Counter_onClick', [store])}>{store.count}</button>;
};
```

`chunk-b.js`:

```tsx
const Counter_onClick = () => {
  const [store] = useLexicalScope();
  return store.count++;
};
```

Обратите внимание, что каждое появление `$` приводит к появлению нового лениво загружаемого символа.

# `$` и правила оптимизатора

Оптимизатор запускается как часть этапа сборки при создании приложения. Задача оптимизатора - разбить приложение на множество небольших, легко загружаемых фрагментов. Оптимизатор перемещает выражения (обычно функции) в новые файлы и оставляет после себя ссылку, указывающую на место, куда было перемещено выражение.

## Значение `$`

Оптимизатору необходимо знать, какое выражение должно быть извлечено в новый файл. Извлечение символа осложняется тем, что ссылка на символ меняется от прямой к асинхронной загрузке. Это означает, что оптимизатор должен работать в паре с исполнительной средой, чтобы знать, какие символы могут быть извлечены и как исполнительная среда может затем загрузить их.

Давайте рассмотрим гипотетическую проблему действия скролла. У вас может возникнуть соблазн написать код следующим образом:

```tsx
function onScroll(fn: () => void) {
  document.addEventListener('scroll', fn);
}

onScroll(() => alert('scroll'));
```

Проблема этого подхода заключается в том, что обработчик события загружается сразу, даже если событие прокрутки никогда не срабатывает. Необходим способ ссылки на код с возможностью ленивой загрузки.

Разработчик может написать:

```tsx
export scrollHandler = () => alert('scroll');

onScroll(() => (await import('./some-chunk')).scrollHandler());
```

Это работает, но требует больших усилий. Разработчик отвечает за размещение кода в другом файле и жёстко фиксирует имя чанка. Вместо этого мы используем оптимизатор, который выполняет эту работу за нас автоматически. Но нам нужен способ сообщить ему, что мы хотим выполнить такой рефакторинг. Для этой цели мы используем `$()` в качестве функции-маркера.

```tsx
function onScroll(fnQrl: QRL<() => void>) {
  document.addEventListener('scroll', async () => {
    fn = await qImport(document, fnQrl);
    fn();
  });
}

onScroll($(() => alert('clicked')));
```

Оптимизатор сгенерирует:

```tsx
onScroll(qrl('./chunk-a.js', 'onScroll_1'));
```

`chunk-a.js`:

```tsx
export const onScroll_1 = () => alert('scroll');
```

Напоминание:

1. Всё, что нужно было сделать разработчику, это обернуть функцию в `$()` и этим подать сигнал оптимизатору, что функция должна быть перемещена в новый файл и, следовательно, лениво загружена.
2. Функция `onScroll` должна быть реализована несколько иначе, поскольку она должна учитывать тот факт, что `QRL` должен быть загружен перед её использованием. На практике использование `qImport` редко встречается в приложениях Qwik, поскольку фреймворк Qwik предоставляет API более высокого уровня, которые редко ожидают, что разработчик будет работать с `qImport` напрямую.

Однако обёртывание кода в `$()` несколько неудобно. По этой причине оптимизатор неявно обёртывает первый аргумент любого вызова функции, который заканчивается на `$` (кроме того, можно использовать `implicit$FirstArg()` для автоматического выполнения обёртывания и согласования типов функции, принимающей `QRL`).

```tsx
const onScroll$ = implicit$FirstArg(onScroll);

onScroll$(() => alert('scroll'));
```

Теперь у разработчика есть очень простой синтаксис для выражения того, что определенная функция должна быть лениво загружена.

## Извлечение символов

Предположим, что у вас есть такой код:

```tsx
export const MyComp = component$(() => {
  /* определение компонента */
});
```

Оптимизатор разбивает код на два файла:

Оригинальный файл:

```tsx
const MyComp = component(qrl('./chunk-a.js', 'MyComp_onMount'));
```

`chunk-a.js`:

```tsx
export const MyComp_onMount = () => {
  /* определение компонента */
};
```

В результате работы оптимизатора метод `onMount` компонента `MyComp` был извлечён в новый файл. В этом есть несколько преимуществ:

- Родительский компонент может ссылаться на `MyComp` не вдаваясь в детали реализации `MyComp`;
- Теперь у приложения больше точек входа, что даёт сборщику больше способов разбить кодовую базу на части.

# Захват лексическй области

Оптимизатор извлекает выражения (обычно функции) в новые файлы и оставляет после себя `QRL`, указывающий на место ленивой загрузки.

Давайте рассмотрим простой случай:

```tsx
export const Greeter = component$(() => {
  return <span>Привет, мир!</span>;
});
```

это приведет к:

```tsx
const Greeter = component(qrl('./chunk-a.js', 'Greeter_onMount'));
```

`chunk-a.js`:

```tsx
const Greeter_onMount = () => {
  return qrl('./chunk-b.js', 'Greeter_onRender');
};
```

`chunk-b.js`:

```tsx
const Greeter_onRender = () => <span>Привет, мир!</span>;
```

Вышесказанное относится к простым случаям, когда извлечённое замыкание функции не захватывает никаких переменных. Рассмотрим более сложный случай, когда извлечённое замыкание функции лексически захватывает переменные.

```tsx
export const Greeter = component$((props: { name: string }) => {
  const salutation = 'Привет';

  return (
    <span>
      {salutation} {props.name}!
    </span>
  );
});
```

Обычный способ извлечения функций не сработает.

```tsx
const Greeter = component(qrl('./chunk-a.js', 'Greeter_onMount'));
```

`chunk-a.js`:

```tsx
const Greeter_onMount = (props) => {
  const salutation = 'Привет';
  return qrl('./chunk-b.js', 'Greeter_onRender');
};
```

`chunk-b.js`:

```tsx
const Greeter_onRender = () => (
  <span>
    {salutation} {props.name}!
  </span>
);
```

Проблему можно увидеть в файле `chunk-b.js`. Извлечённая функция ссылается на `salutation` и `props`, которые больше не находятся в лексической области видимости функции. По этой причине сгенерированный код должен быть немного другим.

`chunk-a.js`:

```tsx
const Greeter_onMount = (props) => {
  const salutation = 'Привет';
  return qrl('./chunk-b.js', 'Greeter_onRender', [salutation, props]);
};
```

`chunk-b.js`:

```tsx
const Greeter_onRender = () => {
  const [salutation, props] = useLexicalScope();

  return (
    <span>
      {salutation} {props.name}!
    </span>
  );
};
```

Обратите внимание на два изменения:

1. В `QRL` функции `Greeter_onMount` теперь хранится `salutation` и `props`. Это выполняет роль захвата констант внутри замыканий.
2. Сгенерированное замыкание `Greeter_onRender` теперь имеет преамбулу, которая восстанавливает `salutation` и `props` (`const [salutation, props] = useLexicalScope()`).

Способность оптимизатора (и среды выполнения Qwik) захватывать константы лексической области значительно улучшает то, какие функции могут быть извлечены в лениво загружаемые ресурсы. Это мощный инструмент для разбиения сложных приложений на более мелкие, легко загружаемые фрагменты.

# Правила оптимизатора

Задача оптимизатора - разбить большое приложение на множество маленьких, лениво-загружаемых фрагментов.

Оптимизатор может лениво загружать замыкание функции, которое лексически захватывает переменные. Однако существуют пределы возможного, и поэтому оптимизатор поставляется с набором правил.

Поскольку не весь допустимый код JavaScript является допустимым кодом оптимизатора, помните о следующих правилах:

- Все захваченные переменные должны быть объявлены как `const`.
- Все захваченные переменные должны быть либо:
  - сериализуемыми;
  - импортируемыми (либо `import`, либо `export` в этом файле).

`$` — это не только маркер для оптимизатора, но и маркер для разработчика, который должен следовать этим правилам.

> **ПРИМЕЧАНИЕ**: есть планы по линтеру, который сможет проверять применение этих правил.

## Импорт

**ПРАВИЛО**: Если функция, извлекаемая оптимизатором, ссылается на символ верхнего уровня, этот символ должен быть либо импортирован, либо экспортирован.

```tsx
import { importedFn } from '...';
export exportedFn = () => {...};

const salutation = "Привет";

someApi$(() => {
  importedFn(); // OK
  exportedFn(); // OK
  salutation; // Ошибка: salutation не импортируется/экспортируется
})
```

Причина вышеуказанного правила становится очевидной при рассмотрении вывода.

```tsx
import { importedFn } from '...';
export exportedFn = () => { ... };

const salutation = "Привет";

someApi(qrl('./chunk-a.js', 'someApi_1'));
```

`chunk-a.js`:

```tsx
import { importedFn } from '...';
import { exportedFn } from './originalFile';

export const someApi_1 = () => {
  importedFn(); // OK
  exportedFn(); // OK
  salutation; // Ошибка: нет возможности получить ссылку.
};
```

## Замыкания

**ПРАВИЛО**: Если функция лексически захватывает переменную (или параметр), эта переменная должна быть (1) `const` и (2) значение должно быть сериализуемым.

```tsx
function somefn() {
  let count = 0;
  list.foreach((item) => {
    count++;
    const currentCount = count;
    someApi$(() => {
      item; // OK (предполагаемая сериализуемость)
      count; // Ошибка: count - не константа
      currentCount; // OK (предполагаемая сериализуемость)
    });
  });
}
```

Взгляд на сгенерированный код показывает, почему эти правила должны быть именно такими:

```tsx
function somefn() {
  let count = 0;
  list.foreach((item) => {
    count++;
    const currentCount = count;
    someApi$(qrl('./chunk-a.js', '_1', [item, count, currentCount]));
  });
}
```

`chunk-a.js`:

```tsx
export _1 = () => {
  const [item, count, currentCount] = useLexicalScope();

  item; // OK (предполагаемая сериализуемость)
  count; // Ошибка: count - не константа
  currentCount; // OK (предполагаемая сериализуемость)
};
```

Смотри раздел [Сериализация](/docs/concepts/resumable/index.mdx#сериализация) для понимания того, что является сериализуемым.
