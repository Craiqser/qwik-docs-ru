---
title: QRL
contributors:
  - ahhshm
  - manucorporat
  - adamdbradley
---

# QRL

QRL (Qwik URL) - это особая форма URL, которую Qwik использует для ленивой загрузки содержимого.

QRL:

- Специально отформатированные URL-адреса, которые вставляются в HTML в виде атрибутов, чтобы указать Qwik, откуда должны быть загружены обработчики кода;
- Указывает на фрагменты JavaScript, которые должны быть лениво загружены;
- Содержит имя символа, которое необходимо извлечь из фрагмента;
- Может содержать ссылки на объекты с лексической областью (захваченные переменные из замыканий);
- Если путь QRL относительный, то для разрешения полного пути используйте `q:base`.

## QRL-кодирование

```
./path/to/chunk.js#SymbolName
```

В своей простейшей форме QRL содержит `./path/to/chunk.js`, URL-адрес, который браузер может использовать для ленивой загрузки ресурса, и `SymbolName` для извлечения из лениво загруженного чанка.

Qwik использует `q:base` для преобразования QRL в абсолютный URL-адрес, если URL-адрес является относительным (если атрибут `q:base` отсутствует, то в качестве базы используется `document.baseURI`).

## Кодирование захваченных переменных с лексической областью видимости

QRL-адреса также могут восстанавливать переменные с лексической областью видимости. В этом случае переменные кодируются в конце QRL в виде массива индексов атрибута `q:obj`.

```
./path/to/chunk.js#SymbolName[0,2]
```

Массив используется функцией `useLexicalScope()` для восстановления значений переменных.

### Пример

Давайте рассмотрим пример того, как части QRL связаны друг с другом.

Разработчик пишет код простого компонента.

```tsx
const Counter = component$((props: { step: number }) => {
  const state = useStore({ count: 0 });

  return <button onClick$={() => (state.count += props.step || 1)}>{state.count}</button>;
});
```

Оптимизатор разбивает приведенный выше код на части следующим образом:

```tsx
const Counter = component(qrl('./chunk-a.js', 'Counter_onMount'));
```

`chunk-a.js`:

```tsx
export const Counter_onMount = (props) => {
  const store = useStore({ count: 0 });
  return qrl('./chunk-b.js', 'Counter_onRender', [store, props]);
};
```

`chunk-b.js`:

```tsx
const Counter_onRender = () => {
  const [store, props] = useLexicalScope();
  return (
    <button onClick$={qrl('./chunk-c.js', 'Counter_onClick', [store, props])}>{store.count}</button>
  );
};
```

`chunk-c.js`:

```tsx
const Counter_onClick = () => {
  const [store, props] = useLexicalScope();
  return (store.count += props.step || 1);
};
```

### Рендер HTML

Предположим, текущий маршрут - `http://localhost/index.html`

После выполнения приведённого выше кода получается такой HTML:

```html
<html>
  <body q:base="/build/">
    <button q:obj="456, 123" on:click="./chunk-c.js#Counter_onClick[0,1]">0</button>
    <script>
      /*Qwikloader script*/
    </script>
    <script type="qwik/json">
      {...json...}
    </script>
  </body>
</html>
```

Главное, на что следует обратить внимание, это атрибут `on:click`. Этот атрибут считывается Qwikloader-ом, когда пользователь нажимает на кнопку.

1. HTML загружается в браузер, и Qwikloader регистрирует глобальный слушатель `click`. Никакой другой JavaScript не загружается/выполняется в этот момент.
2. Пользователь кликает на `<button>`. Это вызывает событие `click`, которое всплывает и обрабатывается Qwikloader-ом.
3. Qwikloader прослеживает путь всплытия события и ищет атрибут `on:click`, который он находит на `<button>`.
4. Теперь Qwikloader пытается загрузить соответствующий чанк. Для этого Qwikloader должен разрешить относительный путь `./chunk-c.js`. Он использует эти значения для построения абсолютного пути, начинающегося в `<button>` и идущего к документу.
   - `on:click="./chunk-c.js#Counter_onClick[0,2]"`.
   - `<body q:base="/build/">`
   - `document.baseURI = "http://localhost/index.html"`.
   - В результате получается абсолютный URL `http://localhost/build/chunk-c.js`, по которому Qwikloader забирает данные.
5. Qwikloader теперь получает ссылку на функцию `Counter_onClick` из `http://localhost/build/chunk-c.js` и вызывает её.
   ```tsx
   const Counter_onClick = () => {
     const [store, props] = useLexicalScope();
     return (store.count += props.step || 1);
   };
   ```
6. В этот момент выполнение передается из Qwikloader-а в лениво загруженный чанк. Это делается для того, чтобы Qwikloader был как можно меньше, поскольку он встраивается в HTML.
7. `useLexicalScope` импортируется из `@builder.io/qwik` и отвечает за получение `store` и `props` (`const [store, props] = useLexicalScope();`).
8. Происходит парсинг JSON `<script type="qwik/json">{...json...}</script>` и распределение десериализованных объектов по атрибуту `q:obj`. В нашем случае:
   - `<div q:id="123" q:obj="456" q:host>` получает объект с идентификатором `123`. Это будет `store`, созданный в функции `Counter_onMount`.
   - `<button q:obj="456, 123"` получает `store`, а также ссылку на `<div q:id="457">`.
9. После десериализации `qwik/json`, `useLexicalScope` может использовать массив QRL `[0,1]` для поиска в `q:obj="456, 123"`, откуда получает объекты с id `456` и `123`, являющиеся параметрами `<div q:id="123" q:obj="456" q:host>`, а также `store` из функции `Counter_onMount`.

> **ПРИМЕЧАНИЕ:** По соображениям производительности `q:obj` и `<script type="qwik/json">` обновляются только при десериализации приложения в HTML. Когда приложение работает, эти атрибуты могут иметь устаревшие значения.

# Почему просто не динамический `import()`?

Браузеры уже имеют механизм динамического импорта, доступный через `import()`. Почему бы не использовать его вместо того, чтобы изобретать новый формат QRL?

На это есть несколько причин:

1. Для работы Qwik необходимо, чтобы QRL были сериализованы в HTML. Это проблематично для динамического `import()`, поскольку нет простого способа получить относительный URL из выражения `import('./some-path.js')`, чтобы его можно было вставить в HTML.
2. Динамический импорт имеет дело с чанками, но у него нет механизма для ссылки на конкретный фрагмент в чанке.
3. Динамический импорт имеет относительный путь к файлу, который импортируется. Это проблема, потому что когда относительный путь помещается в HTML, он теряет контекст, определяющий, что относительно чего. Когда фреймворк считывает путь из HTML и пытается импортировать его как `import(element.getAttribute('on:click'))`, фреймворк становится контекстом для разрешения относительного пути. Это проблема, поскольку исходный контекст перед сериализацией в HTML был другим.
4. Наконец, QRL кодируют информацию о переменных с лексической областью действия, захваченных в замыкании, и их необходимо восстановить.
5. Требуется, чтобы разработчик написал `import('./file-a.js')`, что означает, что разработчик отвечает за определение границ отложенной загрузки. Это ограничивает нашу способность инструментария автоматически перемещать код.

Из-за вышеуказанных различий Qwik вводит QRL-адреса как механизм для ленивой загрузки замыканий в приложение Qwik.

# Смотрите также

- `qrl`: API, используемый для создания QRL.
- `qImport`: API, используемый для ленивой загрузки символов из QRL.
