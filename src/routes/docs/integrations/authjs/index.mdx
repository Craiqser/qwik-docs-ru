---
title: Qwik City и Auth.js
keywords: 'authentication, auth, oauth'
contributors:
  - the-r3aper7
  - ulic75
---

# Auth.js

[Auth.js](https://authjs.dev/) позволяет разработчикам настроить в вашем веб-приложении процесс аутентификации. Эта библиотека поддерживает широкий спектр [провайдеров аутентификации](https://authjs.dev/reference/core/providers) и другие [опции](https://next-auth.js.org/configuration/options#options). Имейте в виду, что библиотека Auth.js все ещё находится на стадии pre-1.0 и может иметь ошибки.

## Установка

Вы можете легко добавить Auth.js с помощью следующей команды Qwik:

```shell
npm run qwik add auth
```

Эта команда добавит новые пакеты:

- `@auth/core`
- `@builder.io/qwik-auth`

и создаст новый файл с именем `plugin@auth.ts` с примером конфигурации.

### Необходимые ручные действия

После установки пакета auth с помощью `npm run qwik add auth` пакет `@auth/core` необходимо добавить в настройки оптимизации зависимостей в файле `vite.config.js`:

```js {9-11} title="vite.config.js"
export default defineConfig(() => {
  return {
    plugins: [qwikCity(), qwikVite(), tsconfigPaths()],
    preview: {
      headers: {
        'Cache-Control': 'public, max-age=600',
      },
    },
    optimizeDeps: {
      include: [ "@auth/core" ]
    }
  };
});
```

## Qwik API

### useAuthSession

[routerLoader$](/docs/route-loader/), который возвращает объект сессии или пустой объект, если сессия отсутствует. Содержимое возвращаемого объекта сессии настраивается с помощью функции обратного вызова сессии. Данные сессии также можно получить с помощью REST API [session](#session).

```tsx
import { component$ } from '@builder.io/qwik';
import { useAuthSession } from '~/routes/plugin@auth';

export default component$(() => {
  const session = useAuthSession();
  return <p>{session.value?.user?.email}</p>;
});
```

### useAuthSignin

[routeAction$](/docs/action/) используется для инициирования потока регистрации или отправки пользователя на страницу регистрации со списком всех возможных провайдеров. Токен CSRF обрабатывается внутренне при входе в систему с помощью `useAuthSignin`.

#### Параметры

* `providerId`: Необязательный строковый параметр с именем провайдера. Если установлен, то инициирует запрос авторизации к поставщику идентификационных данных. При отсутствии этого параметра происходит перенаправление на встроенную/небрендированную страницу регистрации.
* `options`: Необязательный объект опций.
  * `callbackUrl`: Необязательная строка, указывающая, на какой URL-адрес будет перенаправлен пользователь после входа в систему. По умолчанию используется URL страницы, с которой инициируется вход.
* `authorizationParams`: Необязательный объект дополнительных параметров, передаваемых конечной точке `/authorize`. Некоторые идеи см. в спецификации Authorization Request OIDC.

> **ПРИМЕЧАНИЕ:** Вы также можете установить `authorizationParams` через конфигурацию provider.authorizationParams.

Пример использования `useAuthSignin` с компонентом [&lt;Form&gt;](/docs/action/#using-actions-with-form) и необязательными `providerId` и `options.callbackUrl`:

```tsx
import { component$ } from '@builder.io/qwik';
import { Form } from '@builder.io/qwik-city';
import { useAuthSignin } from '~/routes/plugin@auth';

export default component$(() => {
  const signIn = useAuthSignin();
  return (
    <Form action={signIn}>
      <input type="hidden" name="providerId" value="github" />
      <input type="hidden" name="options.callbackUrl" value="http://qwik-auth-example.com/dashboard" />
      <button>Войти</button>
    </Form>
  );
});
```

Пример использования `useAuthSignin` программно с дополнительными `providerId` и `options.callbackUrl`:

```tsx
import { component$ } from '@builder.io/qwik';
import { useAuthSignin } from '~/routes/plugin@auth';

export default component$(() => {
  const signIn = useAuthSignin();
  return (
    <button onClick$={() => signIn.submit({ providerId: 'github', options: { callbackUrl: 'http://qwik-auth-example.com/dashboard' } })}>Войти</button>
  );
});
```

### useAuthSignout

[routeAction$](/docs/action/), используемый для инициирования процесса выхода из системы. Сессия пользователя будет аннулирована/удалена из кук/базы данных, в зависимости от выбранного вами способа хранения сессий.

#### Параметры

* `callbackUrl`: Необязательная строка, указывающая, на какой URL-адрес будет перенаправлен пользователь после выхода из системы. По умолчанию используется URL страницы, с которой инициируется вход.

'callbackUrl' должен считаться действительным обработчиком функции обратного вызова перенаправления. По умолчанию он требует, чтобы URL был абсолютным URL с тем же именем хоста, или вы можете указать относительный URL, начинающийся со слэша. Если он не совпадает, произойдёт перенаправление на домашнюю страницу. Вы можете определить свою собственную функцию обратного вызова перенаправления, чтобы разрешить другие URL-адреса.

Пример использования `useAuthSignout` с компонентом [&lt;Form&gt;](/docs/action/#using-actions-with-form) и необязательным `callbackUrl`:

```tsx
import { component$ } from '@builder.io/qwik';
import { Form } from '@builder.io/qwik-city';
import { useAuthSignout } from '~/routes/plugin@auth';

export default component$(() => {
  const signOut = useAuthSignout();
  return (
    <Form action={signOut}>
      <input type="hidden" name="callbackUrl" value="/signedout" />
      <button>Выйти</button>
    </Form>
  );
});
```

Пример использования `useAuthSignout` программно с необязательным `callbackUrl`:

```tsx
import { component$ } from '@builder.io/qwik';
import { useAuthSignout } from '~/routes/plugin@auth';

export default component$(() => {
  const signOut = useAuthSignout();
  return <button onClick$={() => signOut.submit({ callbackUrl: '/signedout' })}>Выйти</button>;
});
```

## REST API

Доступны все те же REST API, что и в Auth.js.

### signin

**GET /api/auth/signin**

Отображает встроенную/небрендированную страницу входа в систему.

**POST /api/auth/signin/:provider**

Запускает процесс регистрации для конкретного поставщика услуг. В случае OAuth-провайдера вызов этой конечной точки инициирует запрос авторизации к вашему поставщику идентификационных данных. Эта конечная точка также используется внутренним действием [useAuthSignin](#useauthsignin).

### callback

**GET/POST /api/auth/callback/:provider**

### signout

**GET /api/auth/signout**

Отображает встроенную/небрендированную страницу выхода из системы.

**POST /api/auth/signout**

Обработка выхода пользователя из системы - это POST-представление для предотвращения того, чтобы вредоносные ссылки вызывали выход пользователя из системы без его согласия. Сессия пользователя будет аннулирована/удалена из кук/базы данных, в зависимости от выбранного вами способа хранения сессий. Эта конечная точка также используется внутренним методом [useAuthSignout](#useauthsignout).

### session

**GET /api/auth/session**

Возвращает безопасный для клиента объект сессии - или пустой объект, если сессия отсутствует. Содержимое возвращаемого объекта сессии настраивается с помощью функции обратного вызова сессии. Данные сессии также можно получить с помощью загрузчика маршрута [useAuthSession](#useauthsession).

### csrf

**GET /api/auth/csrf**

Возвращает объект, содержащий CSRF-токен. В NextAuth.js CSRF-защита присутствует на всех маршрутах аутентификации. Он использует "метод двойной отправки кук", который использует HttpOnly-, host-only-куки. CSRF-токен, возвращаемый этой конечной точкой, должен передаваться как переменная формы с именем csrfToken во всех POST-запросах к любой конечной точке API.

### providers

**GET /api/auth/providers**

Возвращает список настроенных сервисов OAuth и подробную информацию (например, URL-адреса входа и функции обратного вызова) для каждой службы. Это полезно для динамического создания пользовательских страниц регистрации и для проверки того, какие URL функций обратного вызова настроены для каждого настроенного провайдера OAuth.

## Примеры

### GitHub

1. Следуйте [руководству GitHub OAuth](https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/creating-an-oauth-app) для получения `GitHub Client ID`, `GitHub Client Secrets` и сгенерируйте `AUTH_SECRET` с помощью `openssl rand -base64 32` или [Secret Generator](https://generate-secret.vercel.app/32).
2. Поскольку по умолчанию `plugin@auth.ts` использует GitHub в качестве примера, нам не нужно ничего менять. Однако можно использовать не только GitHub, но и других провайдеров, или добавить дополнительные. Auth.js также поддерживает множество [дополнительных опций](https://next-auth.js.org/configuration/options#options), которые могут быть установлены в этом файле.

```ts title="src/routes/plugin@auth.ts"
import { serverAuth$ } from '@builder.io/qwik-auth';
import GitHub from '@auth/core/providers/github';
import type { Provider } from '@auth/core/providers';

export const { onRequest, useAuthSession, useAuthSignin, useAuthSignout } = serverAuth$(
  ({ env }) => ({
    secret: env.get("AUTH_SECRET"),
    trustHost: true,
    providers: [
      GitHub({
        clientId: env.get("GITHUB_ID"),
        clientSecret: env.get("GITHUB_SECRET"),
      }),
    ] as Provider[],
  })
);
```

3. Для хранения секретов создайте или отредактируйте файл `.env.local` в корне вашего проекта

```bash title=".env.local"
GITHUB_ID=
GITHUB_SECRET=
AUTH_SECRET=
```

> *ВАЖНО*: Пожалуйста, прочитайте документацию Qwik о [Переменных среды](/docs/env-variables/), чтобы убедиться, что вы безопасно их используете. Секретные токены многих провайдеров должны храниться в безопасности и не раскрываться клиенту/браузеру.

4. Теперь приложение готово к реализации аутентификации с помощью Auth.js.
5. Наслаждайтесь!

### Защита маршрута

Доступ к данным сессии можно получить через маршрут `event.sharedMap`. Таким образом, маршрут может быть защищён и перенаправлен с помощью чего-то подобного, расположенного в `layout.tsx` или на странице `index.tsx`:

```tsx
export const onRequest: RequestHandler = (event) => {
  const session: Session | null = event.sharedMap.get('session');
  if (!session || new Date(session.expires) < new Date()) {
    throw event.redirect(302, `/api/auth/signin?callbackUrl=${event.url.href}`);
  }
};
```

> Примечание: При размещении в layout.tsx убедитесь, что место назначения перенаправления не находится в том же layout.tsx, иначе может возникнуть вечный цикл перенаправления.
