---
title: useClientEffect$()
contributors:
  - manucorporat
  - adamdbradley
  - the-r3aper7
  - felixsanz
---

Используйте `useClientEffect$()` для выполнения кода после возобновления работы компонента. Это часто используется для настройки таймеров или потоков, когда приложение возобновляет работу на клиенте.

## `track()` и `useClientEffect$()`

`useClientEffect$()` получает функцию `track()`, как и `useWatch$()`. Используйте функцию `track()` для запуска эффекта при обновлении состояния хранилища. Дополнительная информация в разделе [реактивность](../../../tutorial/reactivity/explicit/index.mdx).

## Жизненный цикл компонента и SSR

Qwik возобновляем. Возобновляемость означает, что приложение запускается на сервере, а затем передаётся клиенту. На клиенте приложение продолжает выполнение с того места, где остановилось. Частым примером применения является создание компонента на сервере, приостановка, а затем возобновление рабоыт на клиенте. Чтобы сделать компонент полностью функциональным, может потребоваться немедленное выполнение кода на клиенте для установки таймеров или потоков.

`useClientEffect$()` - метод только для клиента (на сервере нет эквивалентного метода).

> **ПРИМЕЧАНИЕ** Используйте `useWatch$()` для реализации поведения, которое должно работать как на клиенте, так и на сервере.

## Когда выполняется `useClientEffect$()`?

Код клиентского эффекта выполняется после возобновления работы компонента. Метод `useClientEffect$()` принимает дополнительный аргумент (`{eagerness:'visible|load|idle'}`), который контролирует, когда эффект будет выполнен. Есть три варианта:

- `visible` (по умолчанию): Выполняет эффект, когда компонент становится видимым. Это более предпочтительный вариант, поскольку он откладывает выполнение эффекта до тех пор, пока компонент не станет видимым, вместо выполнения при запуске приложения (мы пытаемся минимизировать количество кода, запускаемого при старте приложения).
- `load`: Выполняет код как можно скорее. Обычно это происходит сразу после события `DOMContentLoaded`.
- `idle`: Выполняет код, когда срабатывает следующий обратный вызов idle.

### Пример

В примере показан компонент часов, который отображается за пределами экрана. Используйте `useClientEffect$()`, чтобы заставить часы обновлять текущее время каждую секунду пока они работают на клиенте. Мы предоставили служебную функцию `updateClock`, чтобы помочь вам это реализовать.

Помните, что `useClientEffect$()` должна возвращать функцию очистки, которая освободит таймер `setInterval`, чтобы таймер можно было правильно очистить при размонтировании/уничтожении компонента.
