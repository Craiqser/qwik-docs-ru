---
title: Передача замыканий
contributors:
  - adamdbradley
  - Nico385412
  - the-r3aper7
  - jmmon
  - manucorporat
  - mhevery
  - Arthur-Fedotiev
---

Параметры должны быть сериализуемыми, чтобы Qwik мог возобновлять и рендерить каждый компонент независимо от других компонентов на странице. Это создаёт проблему, если мы хотим передать обратный вызов дочернему компоненту. Обратные вызовы - это функции, а функции не являются непосредственно сериализуемыми, но они сериализуемы через `$()`, если их сначала преобразовать в QRL.

## QRL-адреса

Передача функций через сериализуемые границы должна осуществляться через QRL-адреса. QRL - это сериализованная форма функции (смотри [QRL](/docs/(qwik)/advanced/qrl/index.mdx) в разделе "Дополнительно").

В Qwik есть удобный API, оканчивающийся на `$`, который эквивалентен прямому вызову `$()`. Эти две строчки эквивалентны:

- инлайн: `useTask$(() => {...}/>`
- явно: `const callbackQrl = $(() => {...}); useTaskQrl(callbackQrl)`

Чаще всего мы используем первую форму, поскольку она позволяет нам встраивать наши обратные вызовы непосредственно в API. Но иногда необходимо использовать вторую форму, чтобы мы могли провести разделение объявления функции и её использования.

## Объявление параметров обратного вызова

Компонент может объявить обратный вызов в своих параметрах:

- Свойство, которое заканчивается на `$` (как в `goodbye$`);
- Тип свойства - `PropFunction<T>`, где `T` - ленивый ссылочный тип, на который указывает QRL (сигнатура функции).

```tsx
interface MyComponentProps {
  goodbye$: PropFunction<() => void>;
  hello$: PropFunction<() => void>;
}

export const MyComponent = component$((props: MyComponentProps) => { ... });
```

Это позволяет пользователю компонента `<MyComponent>` использовать `goodbye$`, как показано здесь:

```jsx
<MyComponent goodbye$={goodbyeQrl} hello$={() => {...}} />
```

## Использование параметров обратного вызова

Обратите внимание, что компонент `<MyComponent>` получает функцию обратного вызова.

Передача `props.goodbye$` в качестве ссылки на элементе `<button>`:

```jsx
<button onClick$={props.goodbye$}>пока</button>
```

Создание новой функции обратного вызова для `<button>` и вызов QRL.

```jsx
<button
  onClick$={async () => {
    await props.hello$?.invoke('мир');
  }}
>
  привет
</button>
```

Эта форма позволяет элементу `<button>` вызывать функцию обратного вызова с пользовательскими параметрами. Обратите внимание, что для вызова требуются `async` и `await`, поскольку QRL являются лениво загружаемыми.
